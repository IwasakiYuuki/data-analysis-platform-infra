# Configuration file for jupyterhub.

c = get_config()  #noqa

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------
## This is an application.

## The date format used by logging formatters for %(asctime)s
#  Default: '%Y-%m-%d %H:%M:%S'
# c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#  Default: '[%(name)s]%(highlevel)s %(message)s'
# c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#  Choices: any of [0, 10, 20, 30, 40, 50, 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL']
#  Default: 30
# c.Application.log_level = 30

## Configure additional log handlers.
#  
#  The default stderr logs handler is configured by the log_level, log_datefmt
#  and log_format settings.
#  
#  This configuration can be used to configure additional handlers (e.g. to
#  output the log to a file) or for finer control over the default handlers.
#  
#  If provided this should be a logging configuration dictionary, for more
#  information see:
#  https://docs.python.org/3/library/logging.config.html#logging-config-
#  dictschema
#  
#  This dictionary is merged with the base logging configuration which defines
#  the following:
#  
#  * A logging formatter intended for interactive use called
#    ``console``.
#  * A logging handler that writes to stderr called
#    ``console`` which uses the formatter ``console``.
#  * A logger with the name of this application set to ``DEBUG``
#    level.
#  
#  This example adds a new handler that writes to a file:
#  
#  .. code-block:: python
#  
#     c.Application.logging_config = {
#         "handlers": {
#             "file": {
#                 "class": "logging.FileHandler",
#                 "level": "DEBUG",
#                 "filename": "<path/to/file>",
#             }
#         },
#         "loggers": {
#             "<application-name>": {
#                 "level": "DEBUG",
#                 # NOTE: if you don't list the default "console"
#                 # handler here then it will be disabled
#                 "handlers": ["console", "file"],
#             },
#         },
#     }
#  Default: {}
# c.Application.logging_config = {}

## Instead of starting the Application, dump configuration to stdout
#  Default: False
# c.Application.show_config = False

## Instead of starting the Application, dump configuration to stdout (as JSON)
#  Default: False
# c.Application.show_config_json = False

#------------------------------------------------------------------------------
# JupyterHub(Application) configuration
#------------------------------------------------------------------------------
## An Application for starting a Multi-User Jupyter Notebook server.

## Maximum number of concurrent servers that can be active at a time.
#  
#  Setting this can limit the total resources your users can consume.
#  
#  An active server is any server that's not fully stopped. It is considered
#  active from the time it has been requested until the time that it has
#  completely stopped.
#  
#  If this many user servers are active, users will not be able to launch new
#  servers until a server is shutdown. Spawn requests will be rejected with a 429
#  error asking them to try again.
#  
#  If set to 0, no limit is enforced.
#  Default: 0
# c.JupyterHub.active_server_limit = 0

## Duration (in seconds) to determine the number of active users.
#  Default: 1800
# c.JupyterHub.active_user_window = 1800

## Resolution (in seconds) for updating activity
#  
#  If activity is registered that is less than activity_resolution seconds more
#  recent than the current value, the new value will be ignored.
#  
#  This avoids too many writes to the Hub database.
#  Default: 30
# c.JupyterHub.activity_resolution = 30

## DEPRECATED since version 2.0.0.
#  
#          The default admin role has full permissions, use custom RBAC scopes instead to
#          create restricted administrator roles.
#          https://jupyterhub.readthedocs.io/en/stable/rbac/index.html
#  Default: False
# c.JupyterHub.admin_access = False

## DEPRECATED since version 0.7.2, use Authenticator.admin_users instead.
#  Default: set()
# c.JupyterHub.admin_users = set()

## Allow named single-user servers per user
#  Default: False
# c.JupyterHub.allow_named_servers = False

## Answer yes to any questions (e.g. confirm overwrite)
#  Default: False
# c.JupyterHub.answer_yes = False

## The default amount of records returned by a paginated endpoint
#  Default: 50
# c.JupyterHub.api_page_default_limit = 50

## The maximum amount of records that can be returned at once
#  Default: 200
# c.JupyterHub.api_page_max_limit = 200

## PENDING DEPRECATION: consider using services
#  
#          Dict of token:username to be loaded into the database.
#  
#          Allows ahead-of-time generation of API tokens for use by externally managed services,
#          which authenticate as JupyterHub users.
#  
#          Consider using services for general services that talk to the
#  JupyterHub API.
#  Default: {}
# c.JupyterHub.api_tokens = {}

## Authentication for prometheus metrics
#  Default: True
# c.JupyterHub.authenticate_prometheus = True

## Class for authenticating users.
#  
#          This should be a subclass of :class:`jupyterhub.auth.Authenticator`
#  
#          with an :meth:`authenticate` method that:
#  
#          - is a coroutine (asyncio or tornado)
#          - returns username on success, None on failure
#          - takes two arguments: (handler, data),
#            where `handler` is the calling web.RequestHandler,
#            and `data` is the POST form data from the login page.
#  
#          .. versionchanged:: 1.0
#              authenticators may be registered via entry points,
#              e.g. `c.JupyterHub.authenticator_class = 'pam'`
#  
#  Currently installed: 
#    - auth0: oauthenticator.auth0.Auth0OAuthenticator
#    - azuread: oauthenticator.azuread.AzureAdOAuthenticator
#    - bitbucket: oauthenticator.bitbucket.BitbucketOAuthenticator
#    - cilogon: oauthenticator.cilogon.CILogonOAuthenticator
#    - generic-oauth: oauthenticator.generic.GenericOAuthenticator
#    - github: oauthenticator.github.GitHubOAuthenticator
#    - gitlab: oauthenticator.gitlab.GitLabOAuthenticator
#    - globus: oauthenticator.globus.GlobusOAuthenticator
#    - google: oauthenticator.google.GoogleOAuthenticator
#    - local-auth0: oauthenticator.auth0.LocalAuth0OAuthenticator
#    - local-azuread: oauthenticator.azuread.LocalAzureAdOAuthenticator
#    - local-bitbucket: oauthenticator.bitbucket.LocalBitbucketOAuthenticator
#    - local-cilogon: oauthenticator.cilogon.LocalCILogonOAuthenticator
#    - local-generic-oauth: oauthenticator.generic.LocalGenericOAuthenticator
#    - local-github: oauthenticator.github.LocalGitHubOAuthenticator
#    - local-gitlab: oauthenticator.gitlab.LocalGitLabOAuthenticator
#    - local-globus: oauthenticator.globus.LocalGlobusOAuthenticator
#    - local-google: oauthenticator.google.LocalGoogleOAuthenticator
#    - local-openshift: oauthenticator.openshift.LocalOpenShiftOAuthenticator
#    - mediawiki: oauthenticator.mediawiki.MWOAuthenticator
#    - openshift: oauthenticator.openshift.OpenShiftOAuthenticator
#    - native: nativeauthenticator.NativeAuthenticator
#    - default: jupyterhub.auth.PAMAuthenticator
#    - dummy: jupyterhub.auth.DummyAuthenticator
#    - null: jupyterhub.auth.NullAuthenticator
#    - pam: jupyterhub.auth.PAMAuthenticator
#    - ldap: ldapauthenticator.LDAPAuthenticator
#    - ldapauthenticator: ldapauthenticator.LDAPAuthenticator
#    - firstuse: firstuseauthenticator.FirstUseAuthenticator
#    - firstuseauthenticator: firstuseauthenticator.FirstUseAuthenticator
#    - tmp: tmpauthenticator.TmpAuthenticator
#  Default: 'jupyterhub.auth.PAMAuthenticator'
# c.JupyterHub.authenticator_class = 'jupyterhub.auth.PAMAuthenticator'
c.JupyterHub.authenticator_class = 'ldap'

## The base URL of the entire application.
#  
#          Add this to the beginning of all JupyterHub URLs.
#          Use base_url to run JupyterHub within an existing website.
#  Default: '/'
# c.JupyterHub.base_url = '/'

## The public facing URL of the whole JupyterHub application.
#  
#          This is the address on which the proxy will bind.
#          Sets protocol, ip, base_url
#  Default: 'http://:8000'
# c.JupyterHub.bind_url = 'http://:8000'

## Whether to shutdown the proxy when the Hub shuts down.
#  
#          Disable if you want to be able to teardown the Hub while leaving the
#  proxy running.
#  
#          Only valid if the proxy was starting by the Hub process.
#  
#          If both this and cleanup_servers are False, sending SIGINT to the Hub will
#          only shutdown the Hub, leaving everything else running.
#  
#          The Hub should be able to resume from database state.
#  Default: True
# c.JupyterHub.cleanup_proxy = True

## Whether to shutdown single-user servers when the Hub shuts down.
#  
#          Disable if you want to be able to teardown the Hub while leaving the
#  single-user servers running.
#  
#          If both this and cleanup_proxy are False, sending SIGINT to the Hub will
#          only shutdown the Hub, leaving everything else running.
#  
#          The Hub should be able to resume from database state.
#  Default: True
# c.JupyterHub.cleanup_servers = True

## Maximum number of concurrent users that can be spawning at a time.
#  
#  Spawning lots of servers at the same time can cause performance problems for
#  the Hub or the underlying spawning system. Set this limit to prevent bursts of
#  logins from attempting to spawn too many servers at the same time.
#  
#  This does not limit the number of total running servers. See
#  active_server_limit for that.
#  
#  If more than this many users attempt to spawn at a time, their requests will
#  be rejected with a 429 error asking them to try again. Users will have to wait
#  for some of the spawning services to finish starting before they can start
#  their own.
#  
#  If set to 0, no limit is enforced.
#  Default: 100
# c.JupyterHub.concurrent_spawn_limit = 100

## The config file to load
#  Default: 'jupyterhub_config.py'
# c.JupyterHub.config_file = 'jupyterhub_config.py'

## DEPRECATED: does nothing
#  Default: False
# c.JupyterHub.confirm_no_ssl = False

## Enable `__Host-` prefix on authentication cookies.
#  
#          The `__Host-` prefix on JupyterHub cookies provides further
#          protection against cookie tossing when untrusted servers
#          may control subdomains of your jupyterhub deployment.
#  
#          _However_, it also requires that cookies be set on the path `/`,
#          which means they are shared by all JupyterHub components,
#          so a compromised server component will have access to _all_ JupyterHub-related
#          cookies of the visiting browser.
#          It is recommended to only combine `__Host-` cookies with per-user domains.
#  
#          .. versionadded:: 4.1
#  Default: False
# c.JupyterHub.cookie_host_prefix_enabled = False

## Number of days for a login cookie to be valid.
#          Default is two weeks.
#  Default: 14
# c.JupyterHub.cookie_max_age_days = 14

## The cookie secret to use to encrypt cookies.
#  
#          Loaded from the JPY_COOKIE_SECRET env variable by default.
#  
#          Should be exactly 256 bits (32 bytes).
#  Default: traitlets.Undefined
# c.JupyterHub.cookie_secret = traitlets.Undefined

## File in which to store the cookie secret.
#  Default: 'jupyterhub_cookie_secret'
# c.JupyterHub.cookie_secret_file = 'jupyterhub_cookie_secret'

## Custom scopes to define.
#  
#          For use when defining custom roles,
#          to grant users granular permissions
#  
#          All custom scopes must have a description,
#          and must start with the prefix `custom:`.
#  
#          For example::
#  
#              custom_scopes = {
#                  "custom:jupyter_server:read": {
#                      "description": "read-only access to a single-user server",
#                  },
#              }
#  Default: {}
# c.JupyterHub.custom_scopes = {}

## The location of jupyterhub data files (e.g. /usr/local/share/jupyterhub)
#  Default: '/opt/tljh/hub/share/jupyterhub'
# c.JupyterHub.data_files_path = '/opt/tljh/hub/share/jupyterhub'

## Include any kwargs to pass to the database connection.
#          See sqlalchemy.create_engine for details.
#  Default: {}
# c.JupyterHub.db_kwargs = {}

## url for the database. e.g. `sqlite:///jupyterhub.sqlite`
#  Default: 'sqlite:///jupyterhub.sqlite'
# c.JupyterHub.db_url = 'sqlite:///jupyterhub.sqlite'

## log all database transactions. This has A LOT of output
#  Default: False
# c.JupyterHub.debug_db = False

## DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.debug
#  Default: False
# c.JupyterHub.debug_proxy = False

## If named servers are enabled, default name of server to spawn or open when no
#  server is specified, e.g. by user-redirect.
#  
#  Note: This has no effect if named servers are not enabled, and does _not_
#  change the existence or behavior of the default server named `''` (the empty
#  string). This only affects which named server is launched when no server is
#  specified, e.g. by links to `/hub/user-redirect/lab/tree/mynotebook.ipynb`.
#  Default: ''
# c.JupyterHub.default_server_name = ''

## The default URL for users when they arrive (e.g. when user directs to "/")
#  
#  By default, redirects users to their own server.
#  
#  Can be a Unicode string (e.g. '/hub/home') or a callable based on the handler
#  object:
#  
#  ::
#  
#      def default_url_fn(handler):
#          user = handler.current_user
#          if user and user.admin:
#              return '/hub/admin'
#          return '/hub/home'
#  
#      c.JupyterHub.default_url = default_url_fn
#  Default: traitlets.Undefined
# c.JupyterHub.default_url = traitlets.Undefined

## Dict authority:dict(files). Specify the key, cert, and/or
#          ca file for an authority. This is useful for externally managed
#          proxies that wish to use internal_ssl.
#  
#          The files dict has this format (you must specify at least a cert)::
#  
#              {
#                  'key': '/path/to/key.key',
#                  'cert': '/path/to/cert.crt',
#                  'ca': '/path/to/ca.crt'
#              }
#  
#          The authorities you can override: 'hub-ca', 'notebooks-ca',
#          'proxy-api-ca', 'proxy-client-ca', and 'services-ca'.
#  
#          Use with internal_ssl
#  Default: {}
# c.JupyterHub.external_ssl_authorities = {}

## DEPRECATED.
#  
#  If you need to register additional HTTP endpoints please use services instead.
#  Default: []
# c.JupyterHub.extra_handlers = []

## DEPRECATED: use output redirection instead, e.g.
#  
#  jupyterhub &>> /var/log/jupyterhub.log
#  Default: ''
# c.JupyterHub.extra_log_file = ''

## Extra log handlers to set on JupyterHub logger
#  Default: []
# c.JupyterHub.extra_log_handlers = []

## Alternate header to use as the Host (e.g., X-Forwarded-Host)
#          when determining whether a request is cross-origin
#  
#          This may be useful when JupyterHub is running behind a proxy that rewrites
#          the Host header.
#  Default: ''
# c.JupyterHub.forwarded_host_header = ''

## Generate certs used for internal ssl
#  Default: False
# c.JupyterHub.generate_certs = False

## Generate default config file
#  Default: False
# c.JupyterHub.generate_config = False

## The URL on which the Hub will listen. This is a private URL for internal
#  communication. Typically set in combination with hub_connect_url. If a unix
#  socket, hub_connect_url **must** also be set.
#  
#  For example:
#  
#      "http://127.0.0.1:8081"
#      "unix+http://%2Fsrv%2Fjupyterhub%2Fjupyterhub.sock"
#  
#  .. versionadded:: 0.9
#  Default: ''
# c.JupyterHub.hub_bind_url = ''

## The ip or hostname for proxies and spawners to use
#          for connecting to the Hub.
#  
#          Use when the bind address (`hub_ip`) is 0.0.0.0, :: or otherwise different
#          from the connect address.
#  
#          Default: when `hub_ip` is 0.0.0.0 or ::, use `socket.gethostname()`,
#  otherwise use `hub_ip`.
#  
#          Note: Some spawners or proxy implementations might not support hostnames. Check your
#          spawner or proxy documentation to see if they have extra requirements.
#  
#          .. versionadded:: 0.8
#  Default: ''
# c.JupyterHub.hub_connect_ip = ''

## DEPRECATED
#  
#  Use hub_connect_url
#  
#  .. versionadded:: 0.8
#  
#  .. deprecated:: 0.9
#      Use hub_connect_url
#  Default: 0
# c.JupyterHub.hub_connect_port = 0

## The URL for connecting to the Hub. Spawners, services, and the proxy will use
#  this URL to talk to the Hub.
#  
#  Only needs to be specified if the default hub URL is not connectable (e.g.
#  using a unix+http:// bind url).
#  
#  .. seealso::
#      JupyterHub.hub_connect_ip
#      JupyterHub.hub_bind_url
#  
#  .. versionadded:: 0.9
#  Default: ''
# c.JupyterHub.hub_connect_url = ''

## The ip address for the Hub process to *bind* to.
#  
#          By default, the hub listens on localhost only. This address must be accessible from
#          the proxy and user servers. You may need to set this to a public ip or '' for all
#          interfaces if the proxy or user servers are in containers or on a different host.
#  
#          See `hub_connect_ip` for cases where the bind and connect address should differ,
#          or `hub_bind_url` for setting the full bind URL.
#  Default: '127.0.0.1'
# c.JupyterHub.hub_ip = '127.0.0.1'

## The internal port for the Hub process.
#  
#          This is the internal port of the hub itself. It should never be accessed directly.
#          See JupyterHub.port for the public port to use when accessing jupyterhub.
#          It is rare that this port should be set except in cases of port conflict.
#  
#          See also `hub_ip` for the ip and `hub_bind_url` for setting the full
#  bind URL.
#  Default: 8081
# c.JupyterHub.hub_port = 8081

## The routing prefix for the Hub itself.
#  
#  Override to send only a subset of traffic to the Hub. Default is to use the
#  Hub as the default route for all requests.
#  
#  This is necessary for normal jupyterhub operation, as the Hub must receive
#  requests for e.g. `/user/:name` when the user's server is not running.
#  
#  However, some deployments using only the JupyterHub API may want to handle
#  these events themselves, in which case they can register their own default
#  target with the proxy and set e.g. `hub_routespec = /hub/` to serve only the
#  hub's own pages, or even `/hub/api/` for api-only operation.
#  
#  Note: hub_routespec must include the base_url, if any.
#  
#  .. versionadded:: 1.4
#  Default: '/'
# c.JupyterHub.hub_routespec = '/'

## Trigger implicit spawns after this many seconds.
#  
#          When a user visits a URL for a server that's not running,
#          they are shown a page indicating that the requested server
#          is not running with a button to spawn the server.
#  
#          Setting this to a positive value will redirect the user
#          after this many seconds, effectively clicking this button
#          automatically for the users,
#          automatically beginning the spawn process.
#  
#          Warning: this can result in errors and surprising behavior
#          when sharing access URLs to actual servers,
#          since the wrong server is likely to be started.
#  Default: 0
# c.JupyterHub.implicit_spawn_seconds = 0

## Timeout (in seconds) to wait for spawners to initialize
#  
#  Checking if spawners are healthy can take a long time if many spawners are
#  active at hub start time.
#  
#  If it takes longer than this timeout to check, init_spawner will be left to
#  complete in the background and the http server is allowed to start.
#  
#  A timeout of -1 means wait forever, which can mean a slow startup of the Hub
#  but ensures that the Hub is fully consistent by the time it starts responding
#  to requests. This matches the behavior of jupyterhub 1.0.
#  
#  .. versionadded: 1.1.0
#  Default: 10
# c.JupyterHub.init_spawners_timeout = 10

## The location to store certificates automatically created by
#          JupyterHub.
#  
#          Use with internal_ssl
#  Default: 'internal-ssl'
# c.JupyterHub.internal_certs_location = 'internal-ssl'

## Enable SSL for all internal communication
#  
#          This enables end-to-end encryption between all JupyterHub components.
#          JupyterHub will automatically create the necessary certificate
#          authority and sign notebook certificates as they're created.
#  Default: False
# c.JupyterHub.internal_ssl = False

## The public facing ip of the whole JupyterHub application
#          (specifically referred to as the proxy).
#  
#          This is the address on which the proxy will listen. The default is to
#          listen on all interfaces. This is the only address through which JupyterHub
#          should be accessed by users.
#  Default: ''
# c.JupyterHub.ip = ''

## Supply extra arguments that will be passed to Jinja environment.
#  Default: {}
# c.JupyterHub.jinja_environment_options = {}

## Interval (in seconds) at which to update last-activity timestamps.
#  Default: 300
# c.JupyterHub.last_activity_interval = 300

## Dict of `{'group': {'users':['usernames'], 'properties': {}}`  to load at
#  startup.
#  
#  Example::
#  
#      c.JupyterHub.load_groups = {
#          'groupname': {
#              'users': ['usernames'],
#              'properties': {'key': 'value'},
#          },
#      }
#  
#  This strictly *adds* groups and users to groups. Properties, if defined,
#  replace all existing properties.
#  
#  Loading one set of groups, then starting JupyterHub again with a different set
#  will not remove users or groups from previous launches. That must be done
#  through the API.
#  
#  .. versionchanged:: 3.2
#    Changed format of group from list of usernames to dict
#  Default: {}
# c.JupyterHub.load_groups = {}

## List of predefined role dictionaries to load at startup.
#  
#          For instance::
#  
#              load_roles = [
#                              {
#                                  'name': 'teacher',
#                                  'description': 'Access to users' information and group membership',
#                                  'scopes': ['users', 'groups'],
#                                  'users': ['cyclops', 'gandalf'],
#                                  'services': [],
#                                  'groups': []
#                              }
#                          ]
#  
#          All keys apart from 'name' are optional.
#          See all the available scopes in the JupyterHub REST API documentation.
#  
#          Default roles are defined in roles.py.
#  Default: []
# c.JupyterHub.load_roles = []

## The date format used by logging formatters for %(asctime)s
#  See also: Application.log_datefmt
# c.JupyterHub.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#  See also: Application.log_format
# c.JupyterHub.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#  See also: Application.log_level
# c.JupyterHub.log_level = 30

## 
#  See also: Application.logging_config
# c.JupyterHub.logging_config = {}

## Specify path to a logo image to override the Jupyter logo in the banner.
#  Default: ''
# c.JupyterHub.logo_file = ''

## Maximum number of concurrent named servers that can be created by a user at a
#  time.
#  
#  Setting this can limit the total resources a user can consume.
#  
#  If set to 0, no limit is enforced.
#  
#  Can be an integer or a callable/awaitable based on the handler object:
#  
#  ::
#  
#      def named_server_limit_per_user_fn(handler):
#          user = handler.current_user
#          if user and user.admin:
#              return 0
#          return 5
#  
#      c.JupyterHub.named_server_limit_per_user = named_server_limit_per_user_fn
#  Default: 0
# c.JupyterHub.named_server_limit_per_user = 0

## Expiry (in seconds) of OAuth access tokens.
#  
#          The default is to expire when the cookie storing them expires,
#          according to `cookie_max_age_days` config.
#  
#          These are the tokens stored in cookies when you visit
#          a single-user server or service.
#          When they expire, you must re-authenticate with the Hub,
#          even if your Hub authentication is still valid.
#          If your Hub authentication is valid,
#          logging in may be a transparent redirect as you refresh the page.
#  
#          This does not affect JupyterHub API tokens in general,
#          which do not expire by default.
#          Only tokens issued during the oauth flow
#          accessing services and single-user servers are affected.
#  
#          .. versionadded:: 1.4
#              OAuth token expires_in was not previously configurable.
#          .. versionchanged:: 1.4
#              Default now uses cookie_max_age_days so that oauth tokens
#              which are generally stored in cookies,
#              expire when the cookies storing them expire.
#              Previously, it was one hour.
#  Default: 0
# c.JupyterHub.oauth_token_expires_in = 0

## File to write PID
#          Useful for daemonizing JupyterHub.
#  Default: ''
# c.JupyterHub.pid_file = ''

## The public facing port of the proxy.
#  
#          This is the port on which the proxy will listen.
#          This is the only port through which JupyterHub
#          should be accessed by users.
#  Default: 8000
# c.JupyterHub.port = 8000

## DEPRECATED since version 0.8 : Use ConfigurableHTTPProxy.api_url
#  Default: ''
# c.JupyterHub.proxy_api_ip = ''

## DEPRECATED since version 0.8 : Use ConfigurableHTTPProxy.api_url
#  Default: 0
# c.JupyterHub.proxy_api_port = 0

## DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.auth_token
#  Default: ''
# c.JupyterHub.proxy_auth_token = ''

## DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.check_running_interval
#  Default: 5
# c.JupyterHub.proxy_check_interval = 5

## The class to use for configuring the JupyterHub proxy.
#  
#          Should be a subclass of :class:`jupyterhub.proxy.Proxy`.
#  
#          .. versionchanged:: 1.0
#              proxies may be registered via entry points,
#              e.g. `c.JupyterHub.proxy_class = 'traefik'`
#  
#  Currently installed: 
#    - configurable-http-proxy: jupyterhub.proxy.ConfigurableHTTPProxy
#    - default: jupyterhub.proxy.ConfigurableHTTPProxy
#    - traefik_consul: jupyterhub_traefik_proxy.consul.TraefikConsulProxy
#    - traefik_etcd: jupyterhub_traefik_proxy.etcd.TraefikEtcdProxy
#    - traefik_file: jupyterhub_traefik_proxy.fileprovider.TraefikFileProviderProxy
#    - traefik_redis: jupyterhub_traefik_proxy.redis.TraefikRedisProxy
#    - traefik_toml: jupyterhub_traefik_proxy.toml.TraefikTomlProxy
#  Default: 'jupyterhub.proxy.ConfigurableHTTPProxy'
# c.JupyterHub.proxy_class = 'jupyterhub.proxy.ConfigurableHTTPProxy'

## DEPRECATED since version 0.8. Use ConfigurableHTTPProxy.command
#  Default: []
# c.JupyterHub.proxy_cmd = []

## Set the public URL of JupyterHub
#  
#          This will skip any detection of URL and protocol from requests,
#          which isn't always correct when JupyterHub is behind
#          multiple layers of proxies, etc.
#          Usually the failure is detecting http when it's really https.
#  
#          Should include the full, public URL of JupyterHub,
#          including the public-facing base_url prefix
#          (i.e. it should include a trailing slash), e.g.
#          https://jupyterhub.example.org/prefix/
#  Default: ''
# c.JupyterHub.public_url = ''

## Recreate all certificates used within JupyterHub on restart.
#  
#          Note: enabling this feature requires restarting all notebook servers.
#  
#          Use with internal_ssl
#  Default: False
# c.JupyterHub.recreate_internal_certs = False

## Redirect user to server (if running), instead of control panel.
#  Default: True
# c.JupyterHub.redirect_to_server = True

## Purge and reset the database.
#  Default: False
# c.JupyterHub.reset_db = False

## Interval (in seconds) at which to check connectivity of services with web
#  endpoints.
#  Default: 60
# c.JupyterHub.service_check_interval = 60

## Dict of token:servicename to be loaded into the database.
#  
#          Allows ahead-of-time generation of API tokens for use by externally
#  managed services.
#  Default: {}
# c.JupyterHub.service_tokens = {}

## List of service specification dictionaries.
#  
#          A service
#  
#          For instance::
#  
#              services = [
#                  {
#                      'name': 'cull_idle',
#                      'command': ['/path/to/cull_idle_servers.py'],
#                  },
#                  {
#                      'name': 'formgrader',
#                      'url': 'http://127.0.0.1:1234',
#                      'api_token': 'super-secret',
#                      'environment':
#                  }
#              ]
#  Default: []
# c.JupyterHub.services = []

## Instead of starting the Application, dump configuration to stdout
#  See also: Application.show_config
# c.JupyterHub.show_config = False

## Instead of starting the Application, dump configuration to stdout (as JSON)
#  See also: Application.show_config_json
# c.JupyterHub.show_config_json = False

## Shuts down all user servers on logout
#  Default: False
# c.JupyterHub.shutdown_on_logout = False

## The class to use for spawning single-user servers.
#  
#          Should be a subclass of :class:`jupyterhub.spawner.Spawner`.
#  
#          .. versionchanged:: 1.0
#              spawners may be registered via entry points,
#              e.g. `c.JupyterHub.spawner_class = 'localprocess'`
#  
#  Currently installed: 
#    - systemd: systemdspawner.SystemdSpawner
#    - systemdspawner: systemdspawner.SystemdSpawner
#    - default: jupyterhub.spawner.LocalProcessSpawner
#    - localprocess: jupyterhub.spawner.LocalProcessSpawner
#    - simple: jupyterhub.spawner.SimpleLocalProcessSpawner
#  Default: 'jupyterhub.spawner.LocalProcessSpawner'
# c.JupyterHub.spawner_class = 'jupyterhub.spawner.LocalProcessSpawner'

## Path to SSL certificate file for the public facing interface of the proxy
#  
#          When setting this, you should also set ssl_key
#  Default: ''
# c.JupyterHub.ssl_cert = ''

## Path to SSL key file for the public facing interface of the proxy
#  
#          When setting this, you should also set ssl_cert
#  Default: ''
# c.JupyterHub.ssl_key = ''

## Host to send statsd metrics to. An empty string (the default) disables sending
#  metrics.
#  Default: ''
# c.JupyterHub.statsd_host = ''

## Port on which to send statsd metrics about the hub
#  Default: 8125
# c.JupyterHub.statsd_port = 8125

## Prefix to use for all metrics sent by jupyterhub to statsd
#  Default: 'jupyterhub'
# c.JupyterHub.statsd_prefix = 'jupyterhub'

## Hook for constructing subdomains for users and services. Only used when
#  `JupyterHub.subdomain_host` is set.
#  
#  There are two predefined hooks, which can be selected by name:
#  
#  - 'legacy' (deprecated) - 'idna' (default, more robust. No change for _most_
#  usernames)
#  
#  Otherwise, should be a function which must not be async. A custom
#  subdomain_hook should have the signature:
#  
#  def subdomain_hook(name, domain, kind) -> str:
#      ...
#  
#  and should return a unique, valid domain name for all usernames.
#  
#  - `name` is the original name, which may need escaping to be safe as a domain
#  name label - `domain` is the domain of the Hub itself - `kind` will be one of
#  'user' or 'service'
#  
#  JupyterHub itself puts very little limit on usernames to accommodate a wide
#  variety of Authenticators, but your identity provider is likely much more
#  strict, allowing you to make assumptions about the name.
#  
#  The 'idna' hook should produce a valid domain name for any user, using IDNA
#  encoding for unicode usernames, and a truncate-and-hash approach for any
#  usernames that can't be easily encoded into a domain component.
#  
#  .. versionadded:: 5.0
#  Default: 'idna'
# c.JupyterHub.subdomain_hook = 'idna'

## Run single-user servers on subdomains of this host.
#  
#          This should be the full `https://hub.domain.tld[:port]`.
#  
#          Provides additional cross-site protections for javascript served by
#  single-user servers.
#  
#          Requires `<username>.hub.domain.tld` to resolve to the same host as
#  `hub.domain.tld`.
#  
#          In general, this is most easily achieved with wildcard DNS.
#  
#          When using SSL (i.e. always) this also requires a wildcard SSL
#  certificate.
#  Default: ''
# c.JupyterHub.subdomain_host = ''

## Paths to search for jinja templates, before using the default templates.
#  Default: []
# c.JupyterHub.template_paths = []

## Extra variables to be passed into jinja templates.
#  
#          Values in dict may contain callable objects.
#          If value is callable, the current user is passed as argument.
#  
#          Example::
#  
#              def callable_value(user):
#                  # user is generated by handlers.base.get_current_user
#                  with open("/tmp/file.txt", "r") as f:
#                      ret = f.read()
#                  ret = ret.replace("<username>", user.name)
#                  return ret
#  
#              c.JupyterHub.template_vars = {
#                  "key1": "value1",
#                  "key2": callable_value,
#              }
#  Default: {}
# c.JupyterHub.template_vars = {}

## Set the maximum expiration (in seconds) of tokens created via the API.
#  
#  Set to any positive value to disallow creation of tokens with no expiration.
#  
#  0 (default) = no limit.
#  
#  Does not affect:
#  
#  - Server API tokens ($JUPYTERHUB_API_TOKEN is tied to lifetime of the server)
#  - Tokens issued during oauth (use `oauth_token_expires_in`) - Tokens created
#  via the API before configuring this limit
#  
#  .. versionadded:: 5.1
#  Default: 0
# c.JupyterHub.token_expires_in_max_seconds = 0

## Extra settings overrides to pass to the tornado application.
#  Default: {}
# c.JupyterHub.tornado_settings = {}

## Trust user-provided tokens (via JupyterHub.service_tokens)
#          to have good entropy.
#  
#          If you are not inserting additional tokens via configuration file,
#          this flag has no effect.
#  
#          In JupyterHub 0.8, internally generated tokens do not
#          pass through additional hashing because the hashing is costly
#          and does not increase the entropy of already-good UUIDs.
#  
#          User-provided tokens, on the other hand, are not trusted to have good entropy by default,
#          and are passed through many rounds of hashing to stretch the entropy of the key
#          (i.e. user-provided tokens are treated as passwords instead of random keys).
#          These keys are more costly to check.
#  
#          If your inserted tokens are generated by a good-quality mechanism,
#          e.g. `openssl rand -hex 32`, then you can set this flag to True
#          to reduce the cost of checking authentication tokens.
#  Default: False
# c.JupyterHub.trust_user_provided_tokens = False

## Names to include in the subject alternative name.
#  
#          These names will be used for server name verification. This is useful
#          if JupyterHub is being run behind a reverse proxy or services using ssl
#          are on different hosts.
#  
#          Use with internal_ssl
#  Default: []
# c.JupyterHub.trusted_alt_names = []

## Downstream proxy IP addresses to trust.
#  
#          This sets the list of IP addresses that are trusted and skipped when processing
#          the `X-Forwarded-For` header. For example, if an external proxy is used for TLS
#          termination, its IP address should be added to this list to ensure the correct
#          client IP addresses are recorded in the logs instead of the proxy server's IP
#          address.
#  Default: []
# c.JupyterHub.trusted_downstream_ips = []

## Upgrade the database automatically on start.
#  
#          Only safe if database is regularly backed up.
#          Only SQLite databases will be backed up to a local file automatically.
#  Default: False
# c.JupyterHub.upgrade_db = False

## Return 503 rather than 424 when request comes in for a non-running server.
#  
#  Prior to JupyterHub 2.0, we returned a 503 when any request came in for a user
#  server that was currently not running. By default, JupyterHub 2.0 will return
#  a 424 - this makes operational metric dashboards more useful.
#  
#  JupyterLab < 3.2 expected the 503 to know if the user server is no longer
#  running, and prompted the user to start their server. Set this config to true
#  to retain the old behavior, so JupyterLab < 3.2 can continue to show the
#  appropriate UI when the user server is stopped.
#  
#  This option will be removed in a future release.
#  Default: False
# c.JupyterHub.use_legacy_stopped_server_status_code = False

## Callable to affect behavior of /user-redirect/
#  
#  Receives 4 parameters: 1. path - URL path that was provided after /user-
#  redirect/ 2. request - A Tornado HTTPServerRequest representing the current
#  request. 3. user - The currently authenticated user. 4. base_url - The
#  base_url of the current hub, for relative redirects
#  
#  It should return the new URL to redirect to, or None to preserve current
#  behavior.
#  Default: None
# c.JupyterHub.user_redirect_hook = None

#------------------------------------------------------------------------------
# Authenticator(LoggingConfigurable) configuration
#------------------------------------------------------------------------------
## Base class for implementing an authentication provider for JupyterHub

## Set of users that will be granted admin rights on this JupyterHub.
#  
#  Note:
#  
#      As of JupyterHub 2.0,
#      full admin rights should not be required,
#      and more precise permissions can be managed via roles.
#  
#  Caution:
#  
#      Adding users to `admin_users` can only *grant* admin rights,
#      removing a username from the admin_users set **DOES NOT** remove admin rights previously granted.
#  
#      For an authoritative, restricted set of admins,
#      assign explicit membership of the `admin` *role*::
#  
#          c.JupyterHub.load_roles = [
#              {
#                  "name": "admin",
#                  "users": ["admin1", "..."],
#              }
#          ]
#  
#  Admin users can take every possible action on behalf of all users, for
#  example:
#  
#  - Use the admin panel to see list of users logged in - Add / remove users in
#  some authenticators - Restart / halt the hub - Start / stop users' single-user
#  servers - Can access each individual users' single-user server
#  
#  Admin access should be treated the same way root access is.
#  
#  Defaults to an empty set, in which case no user has admin access.
#  Default: set()
# c.Authenticator.admin_users = set()

## Allow every user who can successfully authenticate to access JupyterHub.
#  
#  False by default, which means for most Authenticators, _some_ allow-related
#  configuration is required to allow users to log in.
#  
#  Authenticator subclasses may override the default with e.g.::
#  
#      @default("allow_all")
#      def _default_allow_all(self):
#          # if _any_ auth config (depends on the Authenticator)
#          if self.allowed_users or self.allowed_groups or self.allow_existing_users:
#              return False
#          else:
#              return True
#  
#  .. versionadded:: 5.0
#  
#  .. versionchanged:: 5.0
#      Prior to 5.0, `allow_all` wasn't defined on its own,
#      and was instead implicitly True when no allow config was provided,
#      i.e. `allowed_users` unspecified or empty on the base Authenticator class.
#  
#      To preserve pre-5.0 behavior,
#      set `allow_all = True` if you have no other allow configuration.
#  Default: False
# c.Authenticator.allow_all = False
c.Authenticator.allow_all = True

## Allow existing users to login.
#  
#  Defaults to True if `allowed_users` is set for historical reasons, and False
#  otherwise.
#  
#  With this enabled, all users present in the JupyterHub database are allowed to
#  login. This has the effect of any user who has _previously_ been allowed to
#  login via any means will continue to be allowed until the user is deleted via
#  the /hub/admin page or REST API.
#  
#  .. warning::
#  
#     Before enabling this you should review the existing users in the
#     JupyterHub admin panel at `/hub/admin`. You may find users existing
#     there because they have previously been declared in config such as
#     `allowed_users` or allowed to sign in.
#  
#  .. warning::
#  
#     When this is enabled and you wish to remove access for one or more
#     users previously allowed, you must make sure that they
#     are removed from the jupyterhub database. This can be tricky to do
#     if you stop allowing an externally managed group of users for example.
#  
#  With this enabled, JupyterHub admin users can visit `/hub/admin` or use
#  JupyterHub's REST API to add and remove users to manage who can login.
#  
#  .. versionadded:: 5.0
#  Default: False
# c.Authenticator.allow_existing_users = False

## Set of usernames that should be allowed to login.
#  
#  If unspecified, grants no access. You must set at least one other `allow`
#  configuration if any users are to have permission to access the Hub.
#  
#  Any usernames in `admin_users` will also be allowed to login.
#  Default: set()
# c.Authenticator.allowed_users = set()

## Is there any allow config?
#  
#          Used to show a warning if it looks like nobody can access the Hub,
#          which can happen when upgrading to JupyterHub 5,
#          now that `allow_all` defaults to False.
#  
#          Deployments can set this explicitly to True to suppress
#          the "No allow config found" warning.
#  
#          Will be True if any config tagged with `.tag(allow_config=True)`
#          or starts with `allow` is truthy.
#  
#          .. versionadded:: 5.0
#  Default: False
# c.Authenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#          before forcing a refresh of user auth info.
#  
#          Refreshing auth info allows, e.g. requesting/re-validating auth
#  tokens.
#  
#          See :meth:`.refresh_user` for what happens when user auth info is refreshed
#          (nothing by default).
#  Default: 300
# c.Authenticator.auth_refresh_age = 300

## Automatically begin the login process
#  
#          rather than starting with a "Login with..." link at `/hub/login`
#  
#          To work, `.login_url()` must give a URL other than the default `/hub/login`,
#          such as an oauth handler or another automatic login handler,
#          registered with `.get_handlers()`.
#  
#          .. versionadded:: 0.8
#  Default: False
# c.Authenticator.auto_login = False

## Automatically begin login process for OAuth2 authorization requests
#  
#  When another application is using JupyterHub as OAuth2 provider, it sends
#  users to `/hub/api/oauth2/authorize`. If the user isn't logged in already, and
#  auto_login is not set, the user will be dumped on the hub's home page, without
#  any context on what to do next.
#  
#  Setting this to true will automatically redirect users to login if they aren't
#  logged in *only* on the `/hub/api/oauth2/authorize` endpoint.
#  
#  .. versionadded:: 1.5
#  Default: False
# c.Authenticator.auto_login_oauth2_authorize = False

## Set of usernames that are not allowed to log in.
#  
#  Use this with supported authenticators to restrict which users can not log in.
#  This is an additional block list that further restricts users, beyond whatever
#  restrictions the authenticator has in place.
#  
#  If empty, does not perform any additional restriction.
#  
#  .. versionadded: 0.9
#  
#  .. versionchanged:: 5.2
#      Users blocked via `blocked_users` that may have logged in in the past
#      have all permissions and group membership revoked
#      and all servers stopped at JupyterHub startup.
#      Previously, User permissions (e.g. API tokens)
#      and servers were unaffected and required additional
#      administrator operations to block after a user is added to `blocked_users`.
#  
#  .. versionchanged:: 1.2
#      `Authenticator.blacklist` renamed to `blocked_users`
#  Default: set()
# c.Authenticator.blocked_users = set()

## Delete any users from the database that do not pass validation
#  
#          When JupyterHub starts, `.add_user` will be called
#          on each user in the database to verify that all users are still valid.
#  
#          If `delete_invalid_users` is True,
#          any users that do not pass validation will be deleted from the database.
#          Use this if users might be deleted from an external system,
#          such as local user accounts.
#  
#          If False (default), invalid users remain in the Hub's database
#          and a warning will be issued.
#          This is the default to avoid data loss due to config changes.
#  Default: False
# c.Authenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  
#          auth_state will be encrypted and stored in the Hub's database.
#          This can include things like authentication tokens, etc.
#          to be passed to Spawners as environment variables.
#  
#          Encrypting auth_state requires the cryptography package.
#  
#          Additionally, the JUPYTERHUB_CRYPT_KEY environment variable must
#          contain one (or more, separated by ;) 32B encryption keys.
#          These can be either base64 or hex-encoded.
#  
#          If encryption is unavailable, auth_state cannot be persisted.
#  
#          New in JupyterHub 0.8
#  Default: False
# c.Authenticator.enable_auth_state = False

## Let authenticator manage user groups
#  
#          If True, Authenticator.authenticate and/or .refresh_user
#          may return a list of group names in the 'groups' field,
#          which will be assigned to the user.
#  
#          All group-assignment APIs are disabled if this is True.
#  Default: False
# c.Authenticator.manage_groups = False

## Let authenticator manage roles
#  
#          If True, Authenticator.authenticate and/or .refresh_user
#          may return a list of roles in the 'roles' field,
#          which will be added to the database.
#  
#          When enabled, all role management will be handled by the
#          authenticator; in particular, assignment of roles via
#          `JupyterHub.load_roles` traitlet will not be possible.
#  
#          .. versionadded:: 5.0
#  Default: False
# c.Authenticator.manage_roles = False

## The prompt string for the extra OTP (One Time Password) field.
#  
#  .. versionadded:: 5.0
#  Default: 'OTP:'
# c.Authenticator.otp_prompt = 'OTP:'

## An optional hook function that you can implement to do some bootstrapping work
#  during authentication. For example, loading user account details from an
#  external system.
#  
#  This function is called after the user has passed all authentication checks
#  and is ready to successfully authenticate. This function must return the
#  auth_model dict reguardless of changes to it. The hook is called with 3
#  positional arguments: `(authenticator, handler, auth_model)`.
#  
#  This may be a coroutine.
#  
#  .. versionadded: 1.0
#  
#  Example::
#  
#      import os
#      import pwd
#      def my_hook(authenticator, handler, auth_model):
#          user_data = pwd.getpwnam(auth_model['name'])
#          spawn_data = {
#              'pw_data': user_data
#              'gid_list': os.getgrouplist(auth_model['name'], user_data.pw_gid)
#          }
#  
#          if auth_model['auth_state'] is None:
#              auth_model['auth_state'] = {}
#          auth_model['auth_state']['spawn_data'] = spawn_data
#  
#          return auth_model
#  
#      c.Authenticator.post_auth_hook = my_hook
#  Default: None
# c.Authenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  
#          This forces :meth:`.refresh_user` to be called prior to launching
#          a server, to ensure that auth state is up-to-date.
#  
#          This can be important when e.g. auth tokens that may have expired
#          are passed to the spawner via environment variables from auth_state.
#  
#          If refresh_user cannot refresh the user auth data,
#          launch will fail until the user logs in again.
#  Default: False
# c.Authenticator.refresh_pre_spawn = False

## Prompt for OTP (One Time Password) in the login form.
#  
#  .. versionadded:: 5.0
#  Default: False
# c.Authenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  
#          If True:
#            - stale managed roles will be removed,
#            - stale assignments to managed roles will be removed.
#  
#          Any role not present in `load_managed_roles()` will be considered
#  'stale'.
#  
#          The 'stale' status for role assignments is also determined from
#  `load_managed_roles()` result:
#  
#          - user role assignments status will depend on whether the `users` key
#  is defined or not:
#  
#            * if a list is defined under the `users` key and the user is not listed, then the user role assignment will be considered 'stale',
#            * if the `users` key is not provided, the user role assignment will be preserved;
#          - service and group role assignments will be considered 'stale':
#  
#            * if not included in the `services` and `groups` list,
#            * if the `services` and `groups` keys are not provided.
#  
#          .. versionadded:: 5.0
#  Default: False
# c.Authenticator.reset_managed_roles_on_startup = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  
#          Primarily used to normalize OAuth user names to local users.
#  Default: {}
# c.Authenticator.username_map = {}

## Regular expression pattern that all valid usernames must match.
#  
#  If a username does not match the pattern specified here, authentication will
#  not be attempted.
#  
#  If not set, allow any username.
#  Default: ''
# c.Authenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  Default: set()
# c.Authenticator.whitelist = set()

#------------------------------------------------------------------------------
# OAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## Base class for OAuthenticators.
#  
#  Subclasses should, in an increasing level of customization:
#  
#  - Override the constant `user_auth_state_key`
#  - Override various config's default values, such as
#    `authorize_url`, `token_url`, `userdata_url`, and `login_service`.
#  - Override various methods called by :meth:`authenticate`, which
#    subclasses should not override.
#  - Override handler classes such as `login_handler`, `callback_handler`, and
#    `logout_handler`.

## Allow members of selected groups to sign in and consider them as JupyterHub
#  admins.
#  
#  If this is set and a user isn't part of one of these groups or listed in
#  :attr:`admin_users`, a user signing in will have their admin status revoked.
#  
#  Requires :attr:`manage_groups` to also be `True`.
#  
#  .. versionadded:: 17
#      Previously available only on :class:`.GenericOAuthenticator`
#  Default: set()
# c.OAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.OAuthenticator.admin_users = set()

## Allow all authenticated users to login.
#  
#  Overrides all other `allow` configuration.
#  
#  .. versionadded:: 16.0
#  Default: False
# c.OAuthenticator.allow_all = False

## Allow existing users to login.
#  
#  Enable this if you want to manage user access via the JupyterHub admin page
#  (/hub/admin).
#  
#  With this enabled, all users present in the JupyterHub database are allowed to
#  login. This has the effect of any user who has _previously_ been allowed to
#  login via any means will continue to be allowed until the user is deleted via
#  the /hub/admin page or REST API.
#  
#  .. warning::
#  
#     Before enabling this you should review the existing users in the
#     JupyterHub admin panel at `/hub/admin`. You may find users existing
#     there because they have previously been declared in config such as
#     `allowed_users` or allowed to sign in.
#  
#  .. warning::
#  
#     When this is enabled and you wish to remove access for one or more
#     users previously allowed, you must make sure that they
#     are removed from the jupyterhub database. This can be tricky to do
#     if you stop allowing a group of externally managed users for example.
#  
#  With this enabled, JupyterHub admin users can visit `/hub/admin` or use
#  JupyterHub's REST API to add and remove users to manage who can login.
#  
#  .. versionadded:: 16.0
#  
#  .. versionchanged:: 16.0
#  
#     Before this config was available, the default behavior was to allow
#     existing users if `allowed_users` was configured with one or more
#     user.
#  Default: False
# c.OAuthenticator.allow_existing_users = False

## Allow members of selected JupyterHub groups to log in.
#  
#  Requires :attr:`manage_groups` to also be `True`. Typically also requires
#  :attr:`auth_state_groups_key` to be configured to populate the JupyterHub
#  groups.
#  
#  This option is *independent* of other configuration such as
#  :attr:`.GitLabOAuthenticator.allowed_gitlab_groups`, which do not populate the
#  *JupyterHub* groups, and do not require :attr:`manage_groups` to be True.
#  
#  .. versionadded:: 17
#      Previously available only on :class:`.GenericOAuthenticator`
#  Default: set()
# c.OAuthenticator.allowed_groups = set()

## Allow users who have been granted *all* these scopes to log in.
#  
#  We request all the scopes listed in the 'scope' config, but only a subset of
#  these may be granted by the authorization server. This may happen if the user
#  does not have permissions to access a requested scope, or has chosen to not
#  give consent for a particular scope. If the scopes listed in this config are
#  not granted, the user will not be allowed to log in.
#  
#  The granted scopes will be part of the access token (fetched from
#  self.token_url). See https://datatracker.ietf.org/doc/html/rfc6749#section-3.3
#  for more information.
#  
#  See the OAuth documentation of your OAuth provider for various options.
#  Default: []
# c.OAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.OAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.OAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.OAuthenticator.auth_refresh_age = 300

## Determine groups this user belongs based on contents of auth_state.
#  
#  Can be a string key name (use periods for nested keys), or a callable that
#  accepts the auth state (as a dict) and returns the groups list. Callables may
#  be async.
#  
#  Requires :attr:`manage_groups` to also be `True`.
#  
#  .. versionadded:: 17.0
#      Previously available as :attr:`.GenericOAuthenticator.claim_groups_key`
#  Default: traitlets.Undefined
# c.OAuthenticator.auth_state_groups_key = traitlets.Undefined

## The URL to where the user is to be redirected initially based on the OAuth2
#  protocol. The user will be redirected back with an `authorization grant code`_
#  after authenticating successfully with the identity provider.
#  
#  .. _authorization grant code: https://www.rfc-
#  editor.org/rfc/rfc6749#section-1.3.1
#  
#  For more context, see the `Protocol Flow section <https://www.rfc-
#  editor.org/rfc/rfc6749#section-1.2>`_ in the OAuth2 standard document,
#  specifically steps A-B.
#  Default: ''
# c.OAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.OAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.OAuthenticator.auto_login_oauth2_authorize = False

## Whether or to use HTTP Basic authentication instead of form based
#  authentication in requests to :attr:`token_url`.
#  
#  When using HTTP Basic authentication, a HTTP header is set with the
#  :attr:`client_id` and :attr:`client_secret` encoded in it.
#  
#  When using form based authentication, the `client_id` and `client_secret` is
#  put in the HTTP POST request's body.
#  
#  .. versionchanged:: 16.0.0
#  
#     This configuration now toggles between HTTP Basic authentication and
#     form based authentication when working against the `token_url`.
#  
#     Previously when this was configured True, both would be used contrary
#     to a recommendation in `OAuth 2.0 documentation
#     <https://www.rfc-editor.org/rfc/rfc6749#section-2.3.1>`_.
#  
#  .. versionchanged:: 16.0.2
#  
#     The default value for this configuration for GenericOAuthenticator
#     changed from True to False.
#  Default: False
# c.OAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.OAuthenticator.blocked_users = set()

## The client id of the OAuth2 application registered with the identity provider.
#  Default: ''
# c.OAuthenticator.client_id = ''

## The client secret of the OAuth2 application registered with the identity
#  provider.
#  Default: ''
# c.OAuthenticator.client_secret = ''

## The message to be shown when user was not allowed
#  Default: 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'
# c.OAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.OAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.OAuthenticator.enable_auth_state = False

## Enable Proof Key for Code Exchange (PKCE) for the OAuth2 authorization code
#  flow. For more information, see `RFC 7636
#  <https://datatracker.ietf.org/doc/html/rfc7636>`_.
#  
#  PKCE can be used even if the authorization server does not support it.
#  According to `section 3.1 of RFC 6749 <https://www.rfc-
#  editor.org/rfc/rfc6749#section-3.1>`_:
#  
#      The authorization server MUST ignore unrecognized request parameters.
#  
#  Additionally, `section 5 of RFC 7636
#  <https://datatracker.ietf.org/doc/html/rfc7636#section-5>`_ states:
#  
#      As the OAuth 2.0 [RFC6749] server responses are unchanged by this
#      specification, client implementations of this specification do not
#      need to know if the server has implemented this specification or not
#      and SHOULD send the additional parameters as defined in Section 4 to
#      all servers.
#  
#  Note that S256 is the only code challenge method supported. As per `section
#  4.2 of RFC 6749 <https://www.rfc-editor.org/rfc/rfc6749#section-3.1>`_:
#  
#      If the client is capable of using "S256", it MUST use "S256", as
#      "S256" is Mandatory To Implement (MTI) on the server.
#  Default: True
# c.OAuthenticator.enable_pkce = True

## Extra GET params to send along with the initial OAuth request to the OAuth
#  provider.
#  Default: {}
# c.OAuthenticator.extra_authorize_params = {}

## Extra default kwargs passed to all HTTPRequests.
#  
#  .. code-block:: python
#  
#      # Example: send requests through a proxy
#      c.OAuthenticator.http_request_kwargs = {
#          "proxy_host": "proxy.example.com",
#          "proxy_port": 8080,
#      }
#  
#      # Example: validate against certain root certificates
#      c.OAuthenticator.http_request_kwargs = {
#          "ca_certs": "/path/to/a.crt",
#      }
#  
#  See :external:py:class:`tornado.httpclient.HTTPRequest` for all kwargs options
#  you can pass. Note that the HTTP client making these requests is
#  :external:py:class:`tornado.httpclient.AsyncHTTPClient`.
#  Default: {}
# c.OAuthenticator.http_request_kwargs = {}

## Name of the login service or identity provider that this authenticator is
#  using to authenticate users.
#  
#  This config influences the text on a button shown to unauthenticated users
#  before they click it to login, assuming :attr:`auto_login` isn't configured
#  True.
#  
#  The login button's text will be "Login with <login_service>".
#  Default: 'OAuth 2.0'
# c.OAuthenticator.login_service = 'OAuth 2.0'

## When configured, users are not presented with the JupyterHub logout page, but
#  instead redirected to this destination.
#  Default: ''
# c.OAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.OAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.OAuthenticator.manage_roles = False

## Callable to modify `auth_state`
#  
#  Will be called with the Authenticator instance and the existing auth_state
#  dictionary and must return the new auth_state dictionary::
#  
#      auth_state = [await] modify_auth_state_hook(authenticator, auth_state)
#  
#  This hook is called *before* populating group membership, so can be used to
#  make additional requests to populate additional fields which may then be
#  consumed by :attr:`auth_state_groups_key` to populate groups.
#  
#  This hook may be async.
#  
#  .. versionadded: 17.0
#  Default: None
# c.OAuthenticator.modify_auth_state_hook = None

## Callback URL to use.
#  
#  When registering an OAuth2 application with an identity provider, this is
#  typically called the redirect url.
#  
#  Should very likely be set to `https://[your-domain]/hub/oauth_callback`.
#  Default: ''
# c.OAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.OAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.OAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.OAuthenticator.refresh_pre_spawn = False

## Hook for refreshing user auth info.
#  
#  If given, allows overriding the `refresh_user` behavior. Will be called as::
#  
#      refreshed = await refresh_user_hook(authenticator, user, auth_state)
#  
#  `refresh_user_hook` _may_ be async.
#  
#  where `refreshed` can be:
#  
#  - True (no change)
#  - False (require new login)
#  - auth_model (dict - the new auth model, if anything should be changeed)
#  - None (proceed with default refresh_user behavior -
#    allows overriding refresh_user behavior for _some_ users)
#  
#  .. versionadded:: 17.3
#  Default: None
# c.OAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.OAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.OAuthenticator.reset_managed_roles_on_startup = False

## The OAuth scopes to request.
#  
#  See the OAuth documentation of your OAuth provider for options.
#  Default: []
# c.OAuthenticator.scope = []

## Extra parameters for first POST request exchanging the OAuth code for an
#  Access Token
#  Default: {}
# c.OAuthenticator.token_params = {}

## The URL to where this authenticator makes a request to acquire an `access
#  token`_ based on the authorization code received by the user returning from
#  the :attr:`authorize_url`.
#  
#  .. _access token: https://www.rfc-editor.org/rfc/rfc6749#section-1.4
#  
#  For more context, see the `Protocol Flow section <https://www.rfc-
#  editor.org/rfc/rfc6749#section-1.2>`_ in the OAuth2 standard document,
#  specifically steps C-D.
#  Default: ''
# c.OAuthenticator.token_url = ''

## Extract user details from an id token received via a request to
#  :attr:`token_url`, rather than making a follow-up request to the userinfo
#  endpoint :attr:`userdata_url`.
#  
#  Should only be used if :attr:`token_url` uses HTTPS, to ensure token
#  authenticity.
#  
#  For more context, see `Authentication using the Authorization Code Flow
#  <https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth>`_ in the
#  OIDC Core standard document.
#  Default: False
# c.OAuthenticator.userdata_from_id_token = False

## Userdata params to get user data login information.
#  Default: {}
# c.OAuthenticator.userdata_params = {}

## Method for sending access token in userdata request.
#  
#  Supported methods: header, url.
#  Default: 'header'
# c.OAuthenticator.userdata_token_method = 'header'

## The URL to where this authenticator makes a request to acquire user details
#  with an access token received via a request to the :attr:`token_url`.
#  
#  For more context, see the `Protocol Flow section <https://www.rfc-
#  editor.org/rfc/rfc6749#section-1.2>`_ in the OAuth2 standard document,
#  specifically steps E-F.
#  
#  Incompatible with :attr:`userdata_from_id_token`.
#  Default: ''
# c.OAuthenticator.userdata_url = ''

## When `userdata_url` returns a json response, the username will be taken from
#  this key.
#  
#  Can be a string key name or a callable that accepts the returned userdata json
#  (as a dict) and returns the username.  The callable is useful e.g. for
#  extracting the username from a nested object in the response or doing other
#  post processing.
#  
#  What keys are available will depend on the scopes requested and the
#  authenticator used.
#  Default: traitlets.Undefined
# c.OAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.OAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.OAuthenticator.username_pattern = ''

## Determines if certificates are validated.
#  
#  Only set this to False if you feel confident it will not be a security
#  concern.
#  Default: False
# c.OAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.OAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# GoogleOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## Allow members of selected Google groups to sign in and consider them as
#  JupyterHub admins.
#  
#  This is a mapping of { domain : [set of groups] }.
#  
#  If this is set and a user isn't part of one of these groups or listed in
#  `admin_users`, a user signing in will have their admin status revoked.
#  
#  Use of this requires configuration of `gsuite_administrator` and
#  `google_service_account_keys`.
#  Default: {}
# c.GoogleOAuthenticator.admin_google_groups = {}

## 
#  See also: OAuthenticator.admin_groups
# c.GoogleOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.GoogleOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.GoogleOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.GoogleOAuthenticator.allow_existing_users = False

## Allow members of selected Google groups to sign in.
#  
#  This is a mapping of { domain : [set of groups] }.
#  
#  Use of this requires configuration of `gsuite_administrator` and
#  `google_service_account_keys`.
#  Default: {}
# c.GoogleOAuthenticator.allowed_google_groups = {}

## 
#  See also: OAuthenticator.allowed_groups
# c.GoogleOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.GoogleOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.GoogleOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.GoogleOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.GoogleOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.GoogleOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.GoogleOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.GoogleOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.GoogleOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.GoogleOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.GoogleOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.GoogleOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.GoogleOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.GoogleOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.GoogleOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.GoogleOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.GoogleOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.GoogleOAuthenticator.extra_authorize_params = {}

## Used to determine the default values for `token_url` and `userdata_url`.
#  Default: ''
# c.GoogleOAuthenticator.google_api_url = ''

## .. deprecated:: 0.12
#  
#     Use :attr:`allowed_google_groups`.
#  Default: {}
# c.GoogleOAuthenticator.google_group_whitelist = {}

## Service account keys to use with each domain, see
#  https://developers.google.com/admin-sdk/directory/v1/guides/delegation
#  
#  This is a mapping of { domain : service-key }.
#  
#  Required if and only if `allowed_google_groups` or `admin_google_groups` is
#  configured.
#  Default: {}
# c.GoogleOAuthenticator.google_service_account_keys = {}

## Username of a G Suite Administrator for the service account to act as.
#  
#  This is a mapping of { domain : GSuite-administrator }.
#  
#  Required if and only if `allowed_google_groups` or `admin_google_groups` is
#  configured.
#  Default: {}
# c.GoogleOAuthenticator.gsuite_administrator = {}

## This config has two functions.
#  
#  1. Restrict sign-in to users part of Google organizations/workspaces
#     managing domains, such as `["mycollege.edu"]` or `["college1.edu",
#     "college2.edu"]`.
#  2. If a single domain is specified, usernames with that domain will be
#     stripped to exclude the `@domain` part.
#  
#  Users not restricted by this configuration must still be explicitly allowed by
#  a configuration intended to allow users, like `allow_all`, `allowed_users`, or
#  `allowed_google_groups`.
#  
#  .. warning::
#  
#     Changing this config either to or from having a single entry is a
#     disruptive change as the same Google user will get a new username,
#     either without or with a domain name included.
#  
#  .. versionchanged:: 16.1
#  
#     Now restricts sign-in based on the hd claim, not the domain in the
#     user's email.
#  Default: []
# c.GoogleOAuthenticator.hosted_domain = []

## 
#  See also: OAuthenticator.http_request_kwargs
# c.GoogleOAuthenticator.http_request_kwargs = {}

## Include members of nested Google groups in `allowed_google_groups` and
#  `admin_google_groups` to sign in and/or administer JupyterHub.
#  Default: False
# c.GoogleOAuthenticator.include_nested_groups = False

## 
#  See also: OAuthenticator.login_service
# c.GoogleOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.GoogleOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.GoogleOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.GoogleOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.GoogleOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.GoogleOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.GoogleOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.GoogleOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.GoogleOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.GoogleOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.GoogleOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.GoogleOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.GoogleOAuthenticator.scope = []

## Strip the username to exclude the `@domain` part.  This happens by default
#  when there is only one hosted domain specified
#  
#  .. warning::
#  
#      If domains are stripped from usernames and multiple `hosted_domains` are specified, 
#      there is a chance of clashing usernames.
#  Default: False
# c.GoogleOAuthenticator.strip_domain = False

## 
#  See also: OAuthenticator.token_params
# c.GoogleOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.GoogleOAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.GoogleOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.GoogleOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.GoogleOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.GoogleOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.GoogleOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.GoogleOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.GoogleOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.GoogleOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.GoogleOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# GitHubOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: OAuthenticator.admin_groups
# c.GitHubOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.GitHubOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.GitHubOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.GitHubOAuthenticator.allow_existing_users = False

## 
#  See also: OAuthenticator.allowed_groups
# c.GitHubOAuthenticator.allowed_groups = set()

## Allow members of organizations or organizations' teams by specifying
#  organization names like `org-a` and/or an organizations' team names like
#  `org-b:team-1`.
#  
#  The names can have a human friendly variant with spaces etc, but you should
#  specify the name as seen in a URL. As an example, it should be
#  `jupyterhub:mybinder-org-operators` for the team
#  https://github.com/orgs/jupyterhub/teams/mybinder-org-operators.
#  
#  Requires `read:org` to be set in `scope` to not just allow based on public
#  membership.
#  Default: set()
# c.GitHubOAuthenticator.allowed_organizations = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.GitHubOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.GitHubOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.GitHubOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.GitHubOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.GitHubOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.GitHubOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.GitHubOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.GitHubOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.GitHubOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.GitHubOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.GitHubOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.GitHubOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.GitHubOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.GitHubOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.GitHubOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.GitHubOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.GitHubOAuthenticator.extra_authorize_params = {}

## URL to the GitHub REST API to use.
#  
#  Determined based on `github_url` by default and may never need to be
#  explicitly set.
#  Default: ''
# c.GitHubOAuthenticator.github_api = ''

## .. deprecated:: 0.1
#  
#     Use :attr:`client_id`.
#  Default: ''
# c.GitHubOAuthenticator.github_client_id = ''

## .. deprecated:: 0.1
#  
#     Use :attr:`client_secret`.
#  Default: ''
# c.GitHubOAuthenticator.github_client_secret = ''

## .. deprecated:: 0.12
#  
#     Use :attr:`allowed_organizations`.
#  Default: set()
# c.GitHubOAuthenticator.github_organization_whitelist = set()

## Used to determine the default values for `github_api`, `authorize_url`,
#  `token_url`, and `userdata_url`.
#  Default: ''
# c.GitHubOAuthenticator.github_url = ''

## 
#  See also: OAuthenticator.http_request_kwargs
# c.GitHubOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.GitHubOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.GitHubOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.GitHubOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.GitHubOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.GitHubOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.GitHubOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.GitHubOAuthenticator.otp_prompt = 'OTP:'

## Populates the authentication state dictionary `auth_state` with a key `teams`
#  assigned the list of teams the current user is a member of at the time of
#  authentication. The list of teams is structured like the response of the
#  GitHub API documented in https://docs.github.com/en/rest/reference/teams#list-
#  teams-for-the-authenticated-user.
#  
#  Requires `read:org` to be set in `scope`.
#  
#  Note that authentication state is only be available to a `post_auth_hook`
#  before being discarded unless configured to be persisted via
#  `enable_auth_state`. For more information, see https://jupyterhub.readthedocs.
#  io/en/stable/reference/authenticators.html#authentication-state.
#  Default: False
# c.GitHubOAuthenticator.populate_teams_in_auth_state = False

## 
#  See also: Authenticator.post_auth_hook
# c.GitHubOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.GitHubOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.GitHubOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.GitHubOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.GitHubOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.GitHubOAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.GitHubOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.GitHubOAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.GitHubOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.GitHubOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.GitHubOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.GitHubOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.GitHubOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.GitHubOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.GitHubOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.GitHubOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.GitHubOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# BitbucketOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: OAuthenticator.admin_groups
# c.BitbucketOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.BitbucketOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.BitbucketOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.BitbucketOAuthenticator.allow_existing_users = False

## 
#  See also: OAuthenticator.allowed_groups
# c.BitbucketOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.BitbucketOAuthenticator.allowed_scopes = []

## Allow members of selected Bitbucket teams to sign in.
#  Default: set()
# c.BitbucketOAuthenticator.allowed_teams = set()

## 
#  See also: Authenticator.allowed_users
# c.BitbucketOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.BitbucketOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.BitbucketOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.BitbucketOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.BitbucketOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.BitbucketOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.BitbucketOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.BitbucketOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.BitbucketOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.BitbucketOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.BitbucketOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.BitbucketOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.BitbucketOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.BitbucketOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.BitbucketOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.BitbucketOAuthenticator.extra_authorize_params = {}

## 
#  See also: OAuthenticator.http_request_kwargs
# c.BitbucketOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.BitbucketOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.BitbucketOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.BitbucketOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.BitbucketOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.BitbucketOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.BitbucketOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.BitbucketOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.BitbucketOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.BitbucketOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.BitbucketOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.BitbucketOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.BitbucketOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.BitbucketOAuthenticator.scope = []

## .. deprecated:: 0.12
#  
#     Use :attr:`allowed_teams`.
#  Default: set()
# c.BitbucketOAuthenticator.team_whitelist = set()

## 
#  See also: OAuthenticator.token_params
# c.BitbucketOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.BitbucketOAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.BitbucketOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.BitbucketOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.BitbucketOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.BitbucketOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.BitbucketOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.BitbucketOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.BitbucketOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.BitbucketOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.BitbucketOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# Spawner(LoggingConfigurable) configuration
#------------------------------------------------------------------------------
## Base class for spawning single-user notebook servers.
#  
#      Subclass this, and override the following methods:
#  
#      - load_state
#      - get_state
#      - start
#      - stop
#      - poll
#  
#      As JupyterHub supports multiple users, an instance of the Spawner subclass
#      is created for each user. If there are 20 JupyterHub users, there will be 20
#      instances of the subclass.

## Extra arguments to be passed to the single-user server.
#  
#  Some spawners allow shell-style expansion here, allowing you to use
#  environment variables here. Most, including the default, do not. Consult the
#  documentation for your spawner to verify!
#  Default: []
# c.Spawner.args = []

## An optional hook function that you can implement to pass `auth_state` to the
#  spawner after it has been initialized but before it starts. The `auth_state`
#  dictionary may be set by the `.authenticate()` method of the authenticator.
#  This hook enables you to pass some or all of that information to your spawner.
#  
#  Example::
#  
#      def userdata_hook(spawner, auth_state):
#          spawner.userdata = auth_state["userdata"]
#  
#      c.Spawner.auth_state_hook = userdata_hook
#  Default: None
# c.Spawner.auth_state_hook = None

## The command used for starting the single-user server.
#  
#  Provide either a string or a list containing the path to the startup script
#  command. Extra arguments, other than this path, should be provided via `args`.
#  
#  This is usually set if you want to start the single-user server in a different
#  python environment (with virtualenv/conda) than JupyterHub itself.
#  
#  Some spawners allow shell-style expansion here, allowing you to use
#  environment variables. Most, including the default, do not. Consult the
#  documentation for your spawner to verify!
#  Default: ['jupyterhub-singleuser']
# c.Spawner.cmd = ['jupyterhub-singleuser']

## Maximum number of consecutive failures to allow before shutting down
#  JupyterHub.
#  
#  This helps JupyterHub recover from a certain class of problem preventing
#  launch in contexts where the Hub is automatically restarted (e.g. systemd,
#  docker, kubernetes).
#  
#  A limit of 0 means no limit and consecutive failures will not be tracked.
#  Default: 0
# c.Spawner.consecutive_failure_limit = 0

## Minimum number of cpu-cores a single-user notebook server is guaranteed to
#  have available.
#  
#  If this value is set to 0.5, allows use of 50% of one CPU. If this value is
#  set to 2, allows use of up to 2 CPUs.
#  
#  **This is a configuration setting. Your spawner must implement support for the
#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**
#  implement this support. A custom spawner **must** add support for this setting
#  for it to be enforced.
#  Default: None
# c.Spawner.cpu_guarantee = None

## Maximum number of cpu-cores a single-user notebook server is allowed to use.
#  
#  If this value is set to 0.5, allows use of 50% of one CPU. If this value is
#  set to 2, allows use of up to 2 CPUs.
#  
#  The single-user notebook server will never be scheduled by the kernel to use
#  more cpu-cores than this. There is no guarantee that it can access this many
#  cpu-cores.
#  
#  **This is a configuration setting. Your spawner must implement support for the
#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**
#  implement this support. A custom spawner **must** add support for this setting
#  for it to be enforced.
#  Default: None
# c.Spawner.cpu_limit = None

## Enable debug-logging of the single-user server
#  Default: False
# c.Spawner.debug = False

## The URL the single-user server should start in.
#  
#  `{username}` will be expanded to the user's username
#  
#  Example uses:
#  
#  - You can set `notebook_dir` to `/` and `default_url` to `/tree/home/{username}` to allow people to
#    navigate the whole filesystem from their notebook server, but still start in their home directory.
#  - Start with `/notebooks` instead of `/tree` if `default_url` points to a notebook instead of a directory.
#  - You can set this to `/lab` to have JupyterLab start by default, rather than Jupyter Notebook.
#  Default: ''
# c.Spawner.default_url = ''

## Disable per-user configuration of single-user servers.
#  
#  When starting the user's single-user server, any config file found in the
#  user's $HOME directory will be ignored.
#  
#  Note: a user could circumvent this if the user modifies their Python
#  environment, such as when they have their own conda environments / virtualenvs
#  / containers.
#  Default: False
# c.Spawner.disable_user_config = False

## List of environment variables for the single-user server to inherit from the
#  JupyterHub process.
#  
#  This list is used to ensure that sensitive information in the JupyterHub
#  process's environment (such as `CONFIGPROXY_AUTH_TOKEN`) is not passed to the
#  single-user server's process.
#  Default: ['JUPYTERHUB_SINGLEUSER_APP']
# c.Spawner.env_keep = ['JUPYTERHUB_SINGLEUSER_APP']

## Extra environment variables to set for the single-user server's process.
#  
#  Environment variables that end up in the single-user server's process come from 3 sources:
#    - This `environment` configurable
#    - The JupyterHub process' environment variables that are listed in `env_keep`
#    - Variables to establish contact between the single-user notebook and the hub (such as JUPYTERHUB_API_TOKEN)
#  
#  The `environment` configurable should be set by JupyterHub administrators to
#  add installation specific environment variables. It is a dict where the key is
#  the name of the environment variable, and the value can be a string or a
#  callable. If it is a callable, it will be called with one parameter (the
#  spawner instance), and should return a string fairly quickly (no blocking
#  operations please!).
#  
#  Note that the spawner class' interface is not guaranteed to be exactly same
#  across upgrades, so if you are using the callable take care to verify it
#  continues to work after upgrades!
#  
#  .. versionchanged:: 1.2
#      environment from this configuration has highest priority,
#      allowing override of 'default' env variables,
#      such as JUPYTERHUB_API_URL.
#  Default: {}
# c.Spawner.environment = {}

## Override specific traitlets based on group membership of the user.
#  
#  This can be a dict, or a callable that returns a dict. The keys of the dict
#  are *only* used for lexicographical sorting, to guarantee consistent ordering
#  of the overrides. If it is a callable, it may be async, and will be passed one
#  parameter - the spawner instance. It should return a dictionary.
#  
#  The values of the dict are dicts with the following keys:
#  
#  - `"groups"` - If the user belongs to *any* of these groups, these overrides are
#    applied to their server before spawning.
#  - `"spawner_override"` - a dictionary with overrides to apply to the Spawner
#    settings. Each value can be either the final value to change or a callable that
#    take the `Spawner` instance as parameter and returns the final value.
#    If the traitlet being overriden is a *dictionary*, the dictionary
#    will be *recursively updated*, rather than overriden. If you want to
#    remove a key, set its value to `None`.
#  
#  Example:
#  
#      The following example config will:
#  
#      1. Add the environment variable "AM_I_GROUP_ALPHA" to everyone in the "group-alpha" group
#      2. Add the environment variable "AM_I_GROUP_BETA" to everyone in the "group-beta" group.
#         If a user is part of both "group-beta" and "group-alpha", they will get *both* these env
#         vars, due to the dictionary merging functionality.
#      3. Add a higher memory limit for everyone in the "group-beta" group.
#  
#      ::
#  
#          c.Spawner.group_overrides = {
#              "01-group-alpha-env-add": {
#                  "groups": ["group-alpha"],
#                  "spawner_override": {"environment": {"AM_I_GROUP_ALPHA": "yes"}},
#              },
#              "02-group-beta-env-add": {
#                  "groups": ["group-beta"],
#                  "spawner_override": {"environment": {"AM_I_GROUP_BETA": "yes"}},
#              },
#              "03-group-beta-mem-limit": {
#                  "groups": ["group-beta"],
#                  "spawner_override": {"mem_limit": "2G"}
#              }
#          }
#  Default: traitlets.Undefined
# c.Spawner.group_overrides = traitlets.Undefined

## Timeout (in seconds) before giving up on a spawned HTTP server
#  
#  Once a server has successfully been spawned, this is the amount of time we
#  wait before assuming that the server is unable to accept connections.
#  Default: 30
# c.Spawner.http_timeout = 30

## The URL the single-user server should connect to the Hub.
#  
#  If the Hub URL set in your JupyterHub config is not reachable from spawned
#  notebooks, you can set differnt URL by this config.
#  
#  Is None if you don't need to change the URL.
#  Default: None
# c.Spawner.hub_connect_url = None

## The IP address (or hostname) the single-user server should listen on.
#  
#  Usually either '127.0.0.1' (default) or '0.0.0.0'.
#  
#  The JupyterHub proxy implementation should be able to send packets to this
#  interface.
#  
#  Subclasses which launch remotely or in containers should override the default
#  to '0.0.0.0'.
#  
#  .. versionchanged:: 2.0
#      Default changed to '127.0.0.1', from ''.
#      In most cases, this does not result in a change in behavior,
#      as '' was interpreted as 'unspecified',
#      which used the subprocesses' own default, itself usually '127.0.0.1'.
#  Default: '127.0.0.1'
# c.Spawner.ip = '127.0.0.1'

## Minimum number of bytes a single-user notebook server is guaranteed to have
#  available.
#  
#  Allows the following suffixes:
#    - K -> Kilobytes
#    - M -> Megabytes
#    - G -> Gigabytes
#    - T -> Terabytes
#  
#  **This is a configuration setting. Your spawner must implement support for the
#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**
#  implement this support. A custom spawner **must** add support for this setting
#  for it to be enforced.
#  Default: None
# c.Spawner.mem_guarantee = None

## Maximum number of bytes a single-user notebook server is allowed to use.
#  
#  Allows the following suffixes:
#    - K -> Kilobytes
#    - M -> Megabytes
#    - G -> Gigabytes
#    - T -> Terabytes
#  
#  If the single user server tries to allocate more memory than this, it will
#  fail. There is no guarantee that the single-user notebook server will be able
#  to allocate this much memory - only that it can not allocate more than this.
#  
#  **This is a configuration setting. Your spawner must implement support for the
#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**
#  implement this support. A custom spawner **must** add support for this setting
#  for it to be enforced.
#  Default: None
# c.Spawner.mem_limit = None

## Path to the notebook directory for the single-user server.
#  
#  The user sees a file listing of this directory when the notebook interface is
#  started. The current interface does not easily allow browsing beyond the
#  subdirectories in this directory's tree.
#  
#  `~` will be expanded to the home directory of the user, and {username} will be
#  replaced with the name of the user.
#  
#  Note that this does *not* prevent users from accessing files outside of this
#  path! They can do so with many other means.
#  Default: ''
# c.Spawner.notebook_dir = ''

## Allowed scopes for oauth tokens issued by this server's oauth client.
#  
#          This sets the maximum and default scopes
#          assigned to oauth tokens issued by a single-user server's
#          oauth client (i.e. tokens stored in browsers after authenticating with the server),
#          defining what actions the server can take on behalf of logged-in users.
#  
#          Default is an empty list, meaning minimal permissions to identify users,
#          no actions can be taken on their behalf.
#  
#          If callable, will be called with the Spawner as a single argument.
#          Callables may be async.
#  Default: traitlets.Undefined
# c.Spawner.oauth_client_allowed_scopes = traitlets.Undefined

## Allowed roles for oauth tokens.
#  
#          Deprecated in 3.0: use oauth_client_allowed_scopes
#  
#          This sets the maximum and default roles
#          assigned to oauth tokens issued by a single-user server's
#          oauth client (i.e. tokens stored in browsers after authenticating with the server),
#          defining what actions the server can take on behalf of logged-in users.
#  
#          Default is an empty list, meaning minimal permissions to identify users,
#          no actions can be taken on their behalf.
#  Default: traitlets.Undefined
# c.Spawner.oauth_roles = traitlets.Undefined

## An HTML form for options a user can specify on launching their server.
#  
#  The surrounding `<form>` element and the submit button are already provided.
#  
#  For example:
#  
#  .. code:: html
#  
#      Set your key:
#      <input name="key" val="default_key"></input>
#      <br>
#      Choose a letter:
#      <select name="letter" multiple="true">
#        <option value="A">The letter A</option>
#        <option value="B">The letter B</option>
#      </select>
#  
#  The data from this form submission will be passed on to your spawner in
#  `self.user_options`
#  
#  Instead of a form snippet string, this could also be a callable that takes as
#  one parameter the current spawner instance and returns a string. The callable
#  will be called asynchronously if it returns a future, rather than a str. Note
#  that the interface of the spawner class is not deemed stable across versions,
#  so using this functionality might cause your JupyterHub upgrades to break.
#  Default: traitlets.Undefined
# c.Spawner.options_form = traitlets.Undefined

## Interpret HTTP form data
#  
#  Form data will always arrive as a dict of lists of strings. Override this
#  function to understand single-values, numbers, etc.
#  
#  This should coerce form data into the structure expected by self.user_options,
#  which must be a dict, and should be JSON-serializeable, though it can contain
#  bytes in addition to standard JSON data types.
#  
#  This method should not have any side effects. Any handling of `user_options`
#  should be done in `.start()` to ensure consistent behavior across servers
#  spawned via the API and form submission page.
#  
#  Instances will receive this data on self.user_options, after passing through
#  this function, prior to `Spawner.start`.
#  
#  .. versionchanged:: 1.0
#      user_options are persisted in the JupyterHub database to be reused
#      on subsequent spawns if no options are given.
#      user_options is serialized to JSON as part of this persistence
#      (with additional support for bytes in case of uploaded file data),
#      and any non-bytes non-jsonable values will be replaced with None
#      if the user_options are re-used.
#  Default: traitlets.Undefined
# c.Spawner.options_from_form = traitlets.Undefined

## Interval (in seconds) on which to poll the spawner for single-user server's
#  status.
#  
#  At every poll interval, each spawner's `.poll` method is called, which checks
#  if the single-user server is still running. If it isn't running, then
#  JupyterHub modifies its own state accordingly and removes appropriate routes
#  from the configurable proxy.
#  Default: 30
# c.Spawner.poll_interval = 30

## Jitter fraction for poll_interval.
#  
#  Avoids alignment of poll calls for many Spawners, e.g. when restarting
#  JupyterHub, which restarts all polls for running Spawners.
#  
#  `poll_jitter=0` means no jitter, 0.1 means 10%, etc.
#  Default: 0.1
# c.Spawner.poll_jitter = 0.1

## The port for single-user servers to listen on.
#  
#  Defaults to `0`, which uses a randomly allocated port number each time.
#  
#  If set to a non-zero value, all Spawners will use the same port, which only
#  makes sense if each server is on a different address, e.g. in containers.
#  
#  New in version 0.7.
#  Default: 0
# c.Spawner.port = 0

## An optional hook function that you can implement to do work after the spawner
#  stops.
#  
#  This can be set independent of any concrete spawner implementation.
#  Default: None
# c.Spawner.post_stop_hook = None

## An optional hook function that you can implement to do some bootstrapping work
#  before the spawner starts. For example, create a directory for your user or
#  load initial content.
#  
#  This can be set independent of any concrete spawner implementation.
#  
#  This maybe a coroutine.
#  
#  Example::
#  
#      def my_hook(spawner):
#          username = spawner.user.name
#          spawner.environment["GREETING"] = f"Hello {username}"
#  
#      c.Spawner.pre_spawn_hook = my_hook
#  Default: None
# c.Spawner.pre_spawn_hook = None

## An optional hook function that you can implement to modify the ready event,
#  which will be shown to the user on the spawn progress page when their server
#  is ready.
#  
#  This can be set independent of any concrete spawner implementation.
#  
#  This maybe a coroutine.
#  
#  Example::
#  
#      async def my_ready_hook(spawner, ready_event):
#          ready_event["html_message"] = f"Server {spawner.name} is ready for {spawner.user.name}"
#          return ready_event
#  
#      c.Spawner.progress_ready_hook = my_ready_hook
#  Default: None
# c.Spawner.progress_ready_hook = None

## The list of scopes to request for $JUPYTERHUB_API_TOKEN
#  
#          If not specified, the scopes in the `server` role will be used
#          (unchanged from pre-4.0).
#  
#          If callable, will be called with the Spawner instance as its sole argument
#          (JupyterHub user available as spawner.user).
#  
#          JUPYTERHUB_API_TOKEN will be assigned the _subset_ of these scopes
#          that are held by the user (as in oauth_client_allowed_scopes).
#  
#          .. versionadded:: 4.0
#  Default: traitlets.Undefined
# c.Spawner.server_token_scopes = traitlets.Undefined

## List of SSL alt names
#  
#          May be set in config if all spawners should have the same value(s),
#          or set at runtime by Spawner that know their names.
#  Default: []
# c.Spawner.ssl_alt_names = []

## Whether to include `DNS:localhost`, `IP:127.0.0.1` in alt names
#  Default: True
# c.Spawner.ssl_alt_names_include_local = True

## Timeout (in seconds) before giving up on starting of single-user server.
#  
#  This is the timeout for start to return, not the timeout for the server to
#  respond. Callers of spawner.start will assume that startup has failed if it
#  takes longer than this. start should return when the server process is started
#  and its location is known.
#  Default: 60
# c.Spawner.start_timeout = 60

#------------------------------------------------------------------------------
# LocalProcessSpawner(Spawner) configuration
#------------------------------------------------------------------------------
## A Spawner that uses `subprocess.Popen` to start single-user servers as local
#  processes.
#  
#  Requires local UNIX users matching the authenticated users to exist. Does not
#  work on Windows.
#  
#  This is the default spawner for JupyterHub.
#  
#  Note: This spawner does not implement CPU / memory guarantees and limits.

## 
#  See also: Spawner.args
# c.LocalProcessSpawner.args = []

## 
#  See also: Spawner.auth_state_hook
# c.LocalProcessSpawner.auth_state_hook = None

## 
#  See also: Spawner.cmd
# c.LocalProcessSpawner.cmd = ['jupyterhub-singleuser']

## 
#  See also: Spawner.consecutive_failure_limit
# c.LocalProcessSpawner.consecutive_failure_limit = 0

## 
#  See also: Spawner.cpu_guarantee
# c.LocalProcessSpawner.cpu_guarantee = None

## 
#  See also: Spawner.cpu_limit
# c.LocalProcessSpawner.cpu_limit = None

## Enable debug-logging of the single-user server
#  See also: Spawner.debug
# c.LocalProcessSpawner.debug = False

## 
#  See also: Spawner.default_url
# c.LocalProcessSpawner.default_url = ''

## 
#  See also: Spawner.disable_user_config
# c.LocalProcessSpawner.disable_user_config = False

## 
#  See also: Spawner.env_keep
# c.LocalProcessSpawner.env_keep = ['JUPYTERHUB_SINGLEUSER_APP']

## 
#  See also: Spawner.environment
# c.LocalProcessSpawner.environment = {}

## 
#  See also: Spawner.group_overrides
# c.LocalProcessSpawner.group_overrides = traitlets.Undefined

## 
#  See also: Spawner.http_timeout
# c.LocalProcessSpawner.http_timeout = 30

## 
#  See also: Spawner.hub_connect_url
# c.LocalProcessSpawner.hub_connect_url = None

## Seconds to wait for single-user server process to halt after SIGINT.
#  
#  If the process has not exited cleanly after this many seconds, a SIGTERM is
#  sent.
#  Default: 10
# c.LocalProcessSpawner.interrupt_timeout = 10

## 
#  See also: Spawner.ip
# c.LocalProcessSpawner.ip = '127.0.0.1'

## Seconds to wait for process to halt after SIGKILL before giving up.
#  
#  If the process does not exit cleanly after this many seconds of SIGKILL, it
#  becomes a zombie process. The hub process will log a warning and then give up.
#  Default: 5
# c.LocalProcessSpawner.kill_timeout = 5

## 
#  See also: Spawner.mem_guarantee
# c.LocalProcessSpawner.mem_guarantee = None

## 
#  See also: Spawner.mem_limit
# c.LocalProcessSpawner.mem_limit = None

## 
#  See also: Spawner.notebook_dir
# c.LocalProcessSpawner.notebook_dir = ''

## Allowed scopes for oauth tokens issued by this server's oauth client.
#  See also: Spawner.oauth_client_allowed_scopes
# c.LocalProcessSpawner.oauth_client_allowed_scopes = traitlets.Undefined

## Allowed roles for oauth tokens.
#  See also: Spawner.oauth_roles
# c.LocalProcessSpawner.oauth_roles = traitlets.Undefined

## 
#  See also: Spawner.options_form
# c.LocalProcessSpawner.options_form = traitlets.Undefined

## 
#  See also: Spawner.options_from_form
# c.LocalProcessSpawner.options_from_form = traitlets.Undefined

## 
#  See also: Spawner.poll_interval
# c.LocalProcessSpawner.poll_interval = 30

## 
#  See also: Spawner.poll_jitter
# c.LocalProcessSpawner.poll_jitter = 0.1

## Extra keyword arguments to pass to Popen
#  
#          when spawning single-user servers.
#  
#          For example::
#  
#              popen_kwargs = dict(shell=True)
#  Default: {}
# c.LocalProcessSpawner.popen_kwargs = {}

## 
#  See also: Spawner.port
# c.LocalProcessSpawner.port = 0

## 
#  See also: Spawner.post_stop_hook
# c.LocalProcessSpawner.post_stop_hook = None

## 
#  See also: Spawner.pre_spawn_hook
# c.LocalProcessSpawner.pre_spawn_hook = None

## 
#  See also: Spawner.progress_ready_hook
# c.LocalProcessSpawner.progress_ready_hook = None

## The list of scopes to request for $JUPYTERHUB_API_TOKEN
#  See also: Spawner.server_token_scopes
# c.LocalProcessSpawner.server_token_scopes = traitlets.Undefined

## Specify a shell command to launch.
#  
#          The single-user command will be appended to this list,
#          so it sould end with `-c` (for bash) or equivalent.
#  
#          For example::
#  
#              c.LocalProcessSpawner.shell_cmd = ['bash', '-l', '-c']
#  
#          to launch with a bash login shell, which would set up the user's own
#  complete environment.
#  
#          .. warning::
#  
#              Using shell_cmd gives users control over PATH, etc.,
#              which could change what the jupyterhub-singleuser launch command does.
#              Only use this for trusted users.
#  Default: []
# c.LocalProcessSpawner.shell_cmd = []

## List of SSL alt names
#  See also: Spawner.ssl_alt_names
# c.LocalProcessSpawner.ssl_alt_names = []

## Whether to include `DNS:localhost`, `IP:127.0.0.1` in alt names
#  See also: Spawner.ssl_alt_names_include_local
# c.LocalProcessSpawner.ssl_alt_names_include_local = True

## 
#  See also: Spawner.start_timeout
# c.LocalProcessSpawner.start_timeout = 60

## Seconds to wait for single-user server process to halt after SIGTERM.
#  
#  If the process does not exit cleanly after this many seconds of SIGTERM, a
#  SIGKILL is sent.
#  Default: 5
# c.LocalProcessSpawner.term_timeout = 5

#------------------------------------------------------------------------------
# AzureAdOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: OAuthenticator.admin_groups
# c.AzureAdOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.AzureAdOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.AzureAdOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.AzureAdOAuthenticator.allow_existing_users = False

## 
#  See also: OAuthenticator.allowed_groups
# c.AzureAdOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.AzureAdOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.AzureAdOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.AzureAdOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.AzureAdOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.AzureAdOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.AzureAdOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.AzureAdOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.AzureAdOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.AzureAdOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.AzureAdOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.AzureAdOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.AzureAdOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.AzureAdOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.AzureAdOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.AzureAdOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.AzureAdOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.AzureAdOAuthenticator.extra_authorize_params = {}

## 
#  See also: OAuthenticator.http_request_kwargs
# c.AzureAdOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.AzureAdOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.AzureAdOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.AzureAdOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.AzureAdOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.AzureAdOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.AzureAdOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.AzureAdOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.AzureAdOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.AzureAdOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.AzureAdOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.AzureAdOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.AzureAdOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.AzureAdOAuthenticator.scope = []

## An Azure tenant ID for which an OAuth application is registered via
#  `client_id` and `client_secret`.
#  
#  This is used to set the default values of `authorize_url` and `token_url`.
#  Default: ''
# c.AzureAdOAuthenticator.tenant_id = ''

## 
#  See also: OAuthenticator.token_params
# c.AzureAdOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.AzureAdOAuthenticator.token_url = ''

## .. deprecated:: 17.0
#  
#      Use :attr:`auth_state_groups_key` instead.
#  Default: ''
# c.AzureAdOAuthenticator.user_groups_claim = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.AzureAdOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.AzureAdOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.AzureAdOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.AzureAdOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.AzureAdOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.AzureAdOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.AzureAdOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.AzureAdOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.AzureAdOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# GlobusOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## The Globus OAuthenticator handles authentication, authorization, and sets
#  transfer tokens on the spawner environment variables via a pre_spawn_start
#  hook.

## Allow members of selected Globus groups to sign in and consider them as
#  JupyterHub admins. Globus groups should be specified using their UUIDs.
#  
#  If this is set and a user isn't part of one of these groups or listed in
#  `admin_users`, a user signing in will have their admin status revoked.
#  
#  If this is configured, the default value of the scope configuration is
#  appended with the scope
#  `urn:globus:auth:scope:groups.api.globus.org:view_my_groups_and_memberships`.
#  Default: set()
# c.GlobusOAuthenticator.admin_globus_groups = set()

## 
#  See also: OAuthenticator.admin_groups
# c.GlobusOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.GlobusOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.GlobusOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.GlobusOAuthenticator.allow_existing_users = False

## Allow members of selected Globus groups to sign in. Globus groups should be
#  specified using their UUIDs.
#  
#  If this is configured, the default value of the scope configuration is
#  appended with the scope
#  `urn:globus:auth:scope:groups.api.globus.org:view_my_groups_and_memberships`.
#  Default: set()
# c.GlobusOAuthenticator.allowed_globus_groups = set()

## 
#  See also: OAuthenticator.allowed_groups
# c.GlobusOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.GlobusOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.GlobusOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.GlobusOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.GlobusOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.GlobusOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.GlobusOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.GlobusOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.GlobusOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.GlobusOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.GlobusOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.GlobusOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.GlobusOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.GlobusOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.GlobusOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.GlobusOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.GlobusOAuthenticator.enable_pkce = True

## Exclude tokens from being passed into user environments when they start
#  notebooks, Terminals, etc.
#  Default: []
# c.GlobusOAuthenticator.exclude_tokens = []

## 
#  See also: OAuthenticator.extra_authorize_params
# c.GlobusOAuthenticator.extra_authorize_params = {}

## Globus URL to get list of user's Groups.
#  Default: 'https://groups.api.globus.org/v2/groups/my_groups'
# c.GlobusOAuthenticator.globus_groups_url = 'https://groups.api.globus.org/v2/groups/my_groups'

## If JupyterHub is also a Globus endpoint, its endpoint id can be specified
#  here.
#  Default: ''
# c.GlobusOAuthenticator.globus_local_endpoint = ''

## 
#  See also: OAuthenticator.http_request_kwargs
# c.GlobusOAuthenticator.http_request_kwargs = {}

## Restrict which institution (domain) a user can use to login (GlobusID,
#  University of Hogwarts, etc.). This should be set in the app at
#  developers.globus.org, but this acts as an additional check to prevent
#  unnecessary account creation.
#  
#  Note that users with an associated email domains must still be allowed via
#  another config, such as `allow_all`.
#  Default: ''
# c.GlobusOAuthenticator.identity_provider = ''

## 
#  See also: OAuthenticator.login_service
# c.GlobusOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.GlobusOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.GlobusOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.GlobusOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.GlobusOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.GlobusOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.GlobusOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.GlobusOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.GlobusOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.GlobusOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.GlobusOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.GlobusOAuthenticator.reset_managed_roles_on_startup = False

## Globus URL to revoke live tokens.
#  Default: 'https://auth.globus.org/v2/oauth2/token/revoke'
# c.GlobusOAuthenticator.revocation_url = 'https://auth.globus.org/v2/oauth2/token/revoke'

## Revoke tokens so they cannot be used again. Single-user servers MUST be
#  restarted after logout in order to get a fresh working set of tokens.
#  Default: False
# c.GlobusOAuthenticator.revoke_tokens_on_logout = False

## 
#  See also: OAuthenticator.scope
# c.GlobusOAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.GlobusOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.GlobusOAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.GlobusOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.GlobusOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.GlobusOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.GlobusOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.GlobusOAuthenticator.username_claim = traitlets.Undefined

## Create username from email address, not preferred username. If an identity
#  provider is specified, email address must be from the same domain. Email scope
#  will be set automatically.
#  Default: False
# c.GlobusOAuthenticator.username_from_email = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.GlobusOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.GlobusOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.GlobusOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.GlobusOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## Base class for Authenticators that work with local Linux/UNIX users
#  
#      Checks for local users, and can attempt to create them if they exist.

## The command to use for creating users as a list of strings
#  
#  For each element in the list, the string USERNAME will be replaced with the
#  user's username. The username will also be appended as the final argument.
#  
#  For Linux, the default value is:
#  
#      ['adduser', '-q', '--gecos', '""', '--disabled-password']
#  
#  To specify a custom home directory, set this to:
#  
#      ['adduser', '-q', '--gecos', '""', '--home', '/customhome/USERNAME', '--
#  disabled-password']
#  
#  This will run the command:
#  
#      adduser -q --gecos "" --home /customhome/river --disabled-password river
#  
#  when the user 'river' is created.
#  Default: []
# c.LocalAuthenticator.add_user_cmd = []

## 
#  See also: Authenticator.admin_users
# c.LocalAuthenticator.admin_users = set()

## 
#  See also: Authenticator.allow_all
# c.LocalAuthenticator.allow_all = False

## 
#  See also: Authenticator.allow_existing_users
# c.LocalAuthenticator.allow_existing_users = False

## Allow login from all users in these UNIX groups.
#  
#  .. versionchanged:: 5.0
#      `allowed_groups` may be specified together with allowed_users,
#      to grant access by group OR name.
#  Default: set()
# c.LocalAuthenticator.allowed_groups = set()

## 
#  See also: Authenticator.allowed_users
# c.LocalAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: Authenticator.blocked_users
# c.LocalAuthenticator.blocked_users = set()

## If set to True, will attempt to create local system users if they do not exist
#  already.
#  
#  Supports Linux and BSD variants only.
#  Default: False
# c.LocalAuthenticator.create_system_users = False

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalAuthenticator.enable_auth_state = False

## DEPRECATED: use allowed_groups
#  Default: set()
# c.LocalAuthenticator.group_whitelist = set()

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalAuthenticator.manage_roles = False

## 
#  See also: Authenticator.otp_prompt
# c.LocalAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalAuthenticator.refresh_pre_spawn = False

## 
#  See also: Authenticator.request_otp
# c.LocalAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalAuthenticator.reset_managed_roles_on_startup = False

## Dictionary of uids to use at user creation time. This helps ensure that users
#  created from the database get the same uid each time they are created in
#  temporary deployments or containers.
#  Default: {}
# c.LocalAuthenticator.uids = {}

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalGlobusOAuthenticator(LocalAuthenticator, GlobusOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalGlobusOAuthenticator.add_user_cmd = []

## 
#  See also: GlobusOAuthenticator.admin_globus_groups
# c.LocalGlobusOAuthenticator.admin_globus_groups = set()

## 
#  See also: OAuthenticator.admin_groups
# c.LocalGlobusOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalGlobusOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalGlobusOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalGlobusOAuthenticator.allow_existing_users = False

## 
#  See also: GlobusOAuthenticator.allowed_globus_groups
# c.LocalGlobusOAuthenticator.allowed_globus_groups = set()

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalGlobusOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalGlobusOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalGlobusOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalGlobusOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalGlobusOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalGlobusOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalGlobusOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalGlobusOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalGlobusOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalGlobusOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalGlobusOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.LocalGlobusOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalGlobusOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalGlobusOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalGlobusOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalGlobusOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalGlobusOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalGlobusOAuthenticator.enable_pkce = True

## 
#  See also: GlobusOAuthenticator.exclude_tokens
# c.LocalGlobusOAuthenticator.exclude_tokens = []

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalGlobusOAuthenticator.extra_authorize_params = {}

## 
#  See also: GlobusOAuthenticator.globus_groups_url
# c.LocalGlobusOAuthenticator.globus_groups_url = 'https://groups.api.globus.org/v2/groups/my_groups'

## 
#  See also: GlobusOAuthenticator.globus_local_endpoint
# c.LocalGlobusOAuthenticator.globus_local_endpoint = ''

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalGlobusOAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalGlobusOAuthenticator.http_request_kwargs = {}

## 
#  See also: GlobusOAuthenticator.identity_provider
# c.LocalGlobusOAuthenticator.identity_provider = ''

## 
#  See also: OAuthenticator.login_service
# c.LocalGlobusOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalGlobusOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalGlobusOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalGlobusOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalGlobusOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalGlobusOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalGlobusOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalGlobusOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalGlobusOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalGlobusOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalGlobusOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalGlobusOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: GlobusOAuthenticator.revocation_url
# c.LocalGlobusOAuthenticator.revocation_url = 'https://auth.globus.org/v2/oauth2/token/revoke'

## 
#  See also: GlobusOAuthenticator.revoke_tokens_on_logout
# c.LocalGlobusOAuthenticator.revoke_tokens_on_logout = False

## 
#  See also: OAuthenticator.scope
# c.LocalGlobusOAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.LocalGlobusOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalGlobusOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalGlobusOAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalGlobusOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalGlobusOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalGlobusOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalGlobusOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalGlobusOAuthenticator.username_claim = traitlets.Undefined

## 
#  See also: GlobusOAuthenticator.username_from_email
# c.LocalGlobusOAuthenticator.username_from_email = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalGlobusOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalGlobusOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalGlobusOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalGlobusOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalGoogleOAuthenticator(LocalAuthenticator, GoogleOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalGoogleOAuthenticator.add_user_cmd = []

## 
#  See also: GoogleOAuthenticator.admin_google_groups
# c.LocalGoogleOAuthenticator.admin_google_groups = {}

## 
#  See also: OAuthenticator.admin_groups
# c.LocalGoogleOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalGoogleOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalGoogleOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalGoogleOAuthenticator.allow_existing_users = False

## 
#  See also: GoogleOAuthenticator.allowed_google_groups
# c.LocalGoogleOAuthenticator.allowed_google_groups = {}

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalGoogleOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalGoogleOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalGoogleOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalGoogleOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalGoogleOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalGoogleOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalGoogleOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalGoogleOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalGoogleOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalGoogleOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalGoogleOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.LocalGoogleOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalGoogleOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalGoogleOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalGoogleOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalGoogleOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalGoogleOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalGoogleOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalGoogleOAuthenticator.extra_authorize_params = {}

## 
#  See also: GoogleOAuthenticator.google_api_url
# c.LocalGoogleOAuthenticator.google_api_url = ''

## 
#  See also: GoogleOAuthenticator.google_group_whitelist
# c.LocalGoogleOAuthenticator.google_group_whitelist = {}

## 
#  See also: GoogleOAuthenticator.google_service_account_keys
# c.LocalGoogleOAuthenticator.google_service_account_keys = {}

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalGoogleOAuthenticator.group_whitelist = set()

## 
#  See also: GoogleOAuthenticator.gsuite_administrator
# c.LocalGoogleOAuthenticator.gsuite_administrator = {}

## 
#  See also: GoogleOAuthenticator.hosted_domain
# c.LocalGoogleOAuthenticator.hosted_domain = []

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalGoogleOAuthenticator.http_request_kwargs = {}

## 
#  See also: GoogleOAuthenticator.include_nested_groups
# c.LocalGoogleOAuthenticator.include_nested_groups = False

## 
#  See also: OAuthenticator.login_service
# c.LocalGoogleOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalGoogleOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalGoogleOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalGoogleOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalGoogleOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalGoogleOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalGoogleOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalGoogleOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalGoogleOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalGoogleOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalGoogleOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalGoogleOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.LocalGoogleOAuthenticator.scope = []

## 
#  See also: GoogleOAuthenticator.strip_domain
# c.LocalGoogleOAuthenticator.strip_domain = False

## 
#  See also: OAuthenticator.token_params
# c.LocalGoogleOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalGoogleOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalGoogleOAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalGoogleOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalGoogleOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalGoogleOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalGoogleOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalGoogleOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalGoogleOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalGoogleOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalGoogleOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalGoogleOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LDAPAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: Authenticator.admin_users
# c.LDAPAuthenticator.admin_users = set()

## 
#  See also: Authenticator.allow_all
# c.LDAPAuthenticator.allow_all = False

## 
#  See also: Authenticator.allow_existing_users
# c.LDAPAuthenticator.allow_existing_users = False

## List of LDAP group DNs that users could be members of to be granted access.
#  
#  If a user is in any one of the listed groups, then that user is granted
#  access. Membership is tested by fetching info about each group and looking for
#  the User's dn to be a value of one of `member` or `uniqueMember`, *or* if the
#  username being used to log in with is value of the `uid`.
#  
#  Set to an empty list or None to allow all users that have an LDAP account to
#  log in, without performing any group membership checks.
#  
#  When combined with `search_filter`, this strictly reduces the allowed users,
#  i.e. `search_filter` AND `allowed_groups` must both be satisfied.
#  Default: []
# c.LDAPAuthenticator.allowed_groups = []

## 
#  See also: Authenticator.allowed_users
# c.LDAPAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LDAPAuthenticator.any_allow_config = False

## List of attributes to be passed in the LDAP search with `search_filter`.
#  Default: []
# c.LDAPAuthenticator.attributes = []

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LDAPAuthenticator.auth_refresh_age = 300

## List of user attributes to be returned in auth_state
#  
#  Will be available in `auth_state["user_attributes"]`
#  Default: []
# c.LDAPAuthenticator.auth_state_attributes = []

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LDAPAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LDAPAuthenticator.auto_login_oauth2_authorize = False

## Template from which to construct the full dn when authenticating to LDAP.
#  {username} is replaced with the actual username used to log in.
#  
#  If your LDAP is set in such a way that the userdn can not be formed from a
#  template, but must be looked up with an attribute (such as uid or
#  sAMAccountName), please see `lookup_dn`. It might be particularly relevant for
#  ActiveDirectory installs.
#  
#  String example:
#      uid={username},ou=people,dc=wikimedia,dc=org
#  
#  List example:
#      [
#      	uid={username},ou=people,dc=wikimedia,dc=org,
#      	uid={username},ou=Developers,dc=wikimedia,dc=org
#  	]
#  Default: traitlets.Undefined
# c.LDAPAuthenticator.bind_dn_template = traitlets.Undefined

## 
#  See also: Authenticator.blocked_users
# c.LDAPAuthenticator.blocked_users = set()

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LDAPAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LDAPAuthenticator.enable_auth_state = False

## Removed in 2.0, configuring this no longer has any effect.
#  Default: False
# c.LDAPAuthenticator.escape_userdn = False

## List of attributes in the LDAP group to be searched
#  Default: ['member', 'uniqueMember', 'memberUid']
# c.LDAPAuthenticator.group_attributes = ['member', 'uniqueMember', 'memberUid']

## The search filter template used to locate groups that the user belongs to.
#  
#  `{userdn}` and `{uid}` will be replaced with the LDAP user's attributes.
#  
#  Certain server types may use different values, and may also reject invalid
#  values by raising exceptions.
#  Default: '(|(member={userdn})(uniqueMember={userdn})(memberUid={uid}))'
# c.LDAPAuthenticator.group_search_filter = '(|(member={userdn})(uniqueMember={userdn})(memberUid={uid}))'

## Form user's DN by looking up an entry from directory
#  
#  By default, LDAPAuthenticator finds the user's DN by using `bind_dn_template`.
#  However, in some installations, the user's DN does not contain the username,
#  and hence needs to be looked up. You can set this to True and then use
#  `user_search_base` and `user_attribute` to accomplish this.
#  Default: False
# c.LDAPAuthenticator.lookup_dn = False
c.LDAPAuthenticator.lookup_dn = True

## Only used with `lookup_dn=True`.
#  
#  How to query LDAP for user name lookup.
#  
#  Default value `'({login_attr}={login})'` should be good enough for most use
#  cases.
#  Default: '({login_attr}={login})'
# c.LDAPAuthenticator.lookup_dn_search_filter = '({login_attr}={login})'

## Only used with `lookup_dn=True`.
#  
#  Password for a `lookup_dn_search_user`.
#  Default: None
# c.LDAPAuthenticator.lookup_dn_search_password = None

## Only used with `lookup_dn=True`.
#  
#  Technical account for user lookup. If both `lookup_dn_search_user` and
#  `lookup_dn_search_password` are None, then anonymous LDAP query will be done.
#  Default: None
# c.LDAPAuthenticator.lookup_dn_search_user = None

## Only used with `lookup_dn=True`.
#  
#  Attribute containing user's name needed for building DN string. See
#  `user_search_base` for info on how this attribute is used. For most LDAP
#  servers, this is username. For Active Directory, it is `sAMAccountName`.
#  Default: None
# c.LDAPAuthenticator.lookup_dn_user_dn_attribute = None
c.LDAPAuthenticator.lookup_dn_user_dn_attribute = 'uid'

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LDAPAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LDAPAuthenticator.manage_roles = False

## 
#  See also: Authenticator.otp_prompt
# c.LDAPAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LDAPAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LDAPAuthenticator.refresh_pre_spawn = False

## 
#  See also: Authenticator.request_otp
# c.LDAPAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LDAPAuthenticator.reset_managed_roles_on_startup = False

## LDAP3 Search Filter to limit allowed users.
#  
#  That a unique LDAP user is identified with the search_filter is necessary but
#  not sufficient to grant access. Grant access by setting one or more of
#  `allowed_users`, `allow_all`, `allowed_groups`, etc.
#  
#  Users who do not match this filter cannot be allowed by any other
#  configuration.
#  
#  The search filter string will be expanded, so that:
#  
#  - `{userattr}` is replaced with the `user_attribute` config's value.
#  - `{username}` is replaced with an escaped username, either provided
#    directly or previously looked up with `lookup_dn` configured.
#  Default: ''
# c.LDAPAuthenticator.search_filter = ''

## Address of the LDAP server to contact.
#  
#  Could be an IP address or hostname.
#  Default: ''
# c.LDAPAuthenticator.server_address = ''
c.LDAPAuthenticator.server_address = '192.168.1.111'

## Port on which to contact the LDAP server.
#  
#  Defaults to `636` if `tls_strategy="on_connect"` is set, `389` otherwise.
#  Default: 0
# c.LDAPAuthenticator.server_port = 0

## A dictionary that will be used as keyword arguments for the constructor of the
#  ldap3 package's TLS object, influencing encrypted connections to the LDAP
#  server.
#  
#  For details on what can be configured and its effects, refer to the ldap3
#  package's documentation and code:
#  
#  - ldap3 documentation: https://ldap3.readthedocs.io/en/latest/ssltls.html#the-
#  tls-object - ldap3 code:
#  https://github.com/cannatag/ldap3/blob/v2.9.1/ldap3/core/tls.py#L59-L82
#  
#  You can for example configure this like:
#  
#  ```python
#  c.LDAPAuthenticator.tls_kwargs = {
#      "ca_certs_file": "file/path.here",
#  }
#  ```
#  Default: {}
# c.LDAPAuthenticator.tls_kwargs = {}

## When LDAPAuthenticator connects to the LDAP server, it can establish a SSL/TLS
#  connection directly, or do it before binding, which is LDAP terminology for
#  authenticating and sending sensitive credentials.
#  
#  The LDAP v3 protocol deprecated establishing a SSL/TLS connection directly
#  (`tls_strategy="on_connect"`) in favor of upgrading the connection to SSL/TLS
#  before binding (`tls_strategy="before_bind"`).
#  
#  Supported `tls_strategy` values are: - "before_bind" (default) - "on_connect"
#  (deprecated in LDAP v3, associated with use of port 636) - "insecure"
#  
#  When configuring `tls_strategy="on_connect"`, the default value of
#  `server_port` becomes 636.
#  Choices: any of ['before_bind', 'on_connect', 'insecure']
#  Default: <TlsStrategy.before_bind: 1>
# c.LDAPAuthenticator.tls_strategy = <TlsStrategy.before_bind: 1>
c.LDAPAuthenticator.tls_strategy = 'insecure'

## Only used with `lookup_dn=True`.
#  
#  If configured True, the `lookup_dn_user_dn_attribute` value used to build the
#  LDAP user's DN string is also used as the authenticated user's JupyterHub
#  username.
#  
#  If this is configured True, its important to ensure that the values of
#  `lookup_dn_user_dn_attribute` are unique even after the are normalized to be
#  lowercase, otherwise two LDAP users could end up sharing the same JupyterHub
#  username.
#  
#  With ldapauthenticator 2, the default value was changed to False.
#  Default: False
# c.LDAPAuthenticator.use_lookup_dn_username = False

## `use_ssl` is deprecated since 2.0. `use_ssl=True` translates to configuring
#  `tls_strategy="on_connect"`, but `use_ssl=False` (previous default) doesn't
#  translate to anything.
#  Default: None
# c.LDAPAuthenticator.use_ssl = None

## Only used with `lookup_dn=True` or with a configured `search_filter`.
#  
#  Together with `user_search_base`, this attribute will be searched to contain
#  the username provided by the user in JupyterHub's login form.
#  
#  ```python # Active Directory c.LDAPAuthenticator.user_attribute =
#  'sAMAccountName'
#  
#  # OpenLDAP c.LDAPAuthenticator.user_attribute = 'uid' ```
#  Default: None
# c.LDAPAuthenticator.user_attribute = None
c.LDAPAuthenticator.user_attribute = 'uid'

## Only used with `lookup_dn=True` or with a configured `search_filter`.
#  
#  Defines the search base for looking up users in the directory.
#  
#  ```python c.LDAPAuthenticator.user_search_base = 'ou=People,dc=example,dc=com'
#  ```
#  
#  LDAPAuthenticator will search all objects under this base where the
#  `user_attribute` is set to the current username to form the userdn.
#  
#  For example, if all users objects existed under the base
#  `ou=people,dc=wikimedia,dc=org`, the username is set with the attribute `uid`,
#  you can use the following config:
#  
#  ```python c.LDAPAuthenticator.lookup_dn = True
#  c.LDAPAuthenticator.lookup_dn_search_filter = '({login_attr}={login})'
#  c.LDAPAuthenticator.lookup_dn_search_user =
#  'ldap_search_user_technical_account'
#  c.LDAPAuthenticator.lookup_dn_search_password = 'secret'
#  c.LDAPAuthenticator.user_search_base = 'ou=people,dc=wikimedia,dc=org'
#  c.LDAPAuthenticator.user_attribute = 'uid'
#  c.LDAPAuthenticator.lookup_dn_user_dn_attribute = 'sAMAccountName' ```
#  Default: None
# c.LDAPAuthenticator.user_search_base = None
c.LDAPAuthenticator.user_search_base = "ou=People,ou=development,dc=home"

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LDAPAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LDAPAuthenticator.username_pattern = ''

## Regex for validating usernames - those that do not match this regex will be
#  rejected.
#  
#  This config was primarily introduced to prevent LDAP injection
#  (https://www.owasp.org/index.php/LDAP_injection), but that is since 2.0 being
#  mitigated by escaping all sensitive characters when interacting with the LDAP
#  server.
#  Default: '^[a-z][.a-z0-9_-]*$'
# c.LDAPAuthenticator.valid_username_regex = '^[a-z][.a-z0-9_-]*$'

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LDAPAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# Proxy(LoggingConfigurable) configuration
#------------------------------------------------------------------------------
## Base class for configurable proxies that JupyterHub can use.
#  
#      A proxy implementation should subclass this and must define the following
#  methods:
#  
#      - :meth:`.get_all_routes` return a dictionary of all JupyterHub-related routes
#      - :meth:`.add_route` adds a route
#      - :meth:`.delete_route` deletes a route
#  
#      In addition to these, the following method(s) may need to be implemented:
#  
#      - :meth:`.start` start the proxy, if it should be launched by the Hub
#        instead of externally managed.
#        If the proxy is externally managed, it should set :attr:`should_start` to False.
#      - :meth:`.stop` stop the proxy. Only used if :meth:`.start` is also used.
#  
#      And the following method(s) are optional, but can be provided:
#  
#      - :meth:`.get_route` gets a single route.
#        There is a default implementation that extracts data from :meth:`.get_all_routes`,
#        but implementations may choose to provide a more efficient implementation
#        of fetching a single route.

## Additional routes to be maintained in the proxy.
#  
#  A dictionary with a route specification as key, and a URL as target. The hub
#  will ensure this route is present in the proxy.
#  
#  If the hub is running in host based mode (with JupyterHub.subdomain_host set),
#  the routespec *must* have a domain component (example.com/my-url/). If the hub
#  is not running in host based mode, the routespec *must not* have a domain
#  component (/my-url/).
#  
#  Helpful when the hub is running in API-only mode.
#  Default: {}
# c.Proxy.extra_routes = {}

## Should the Hub start the proxy
#  
#          If True, the Hub will start the proxy and stop it.
#          Set to False if the proxy is managed externally,
#          such as by systemd, docker, or another service manager.
#  Default: True
# c.Proxy.should_start = True

#------------------------------------------------------------------------------
# TraefikProxy(Proxy) configuration
#------------------------------------------------------------------------------
## JupyterHub Proxy implementation using traefik

## Timeout (in seconds) when waiting for traefik to register an updated route.
#  Default: 30
# c.TraefikProxy.check_route_timeout = 30

## The number of requests allowed to be concurrently outstanding to the proxy
#  
#  Limiting this number avoids potential timeout errors by sending too many
#  requests to update the proxy at once
#  Default: 10
# c.TraefikProxy.concurrency = 10

## Whether to initialize the traefik dynamic configuration from JupyterHub
#  configuration, when should_start is False (dynamic configuration is always
#  applied when should_start is True).
#  
#  Creates the traefik API router and TLS setup, if any. When True, only traefik
#  static configuration must be managed by the external service (configuration of
#  the endpoints and provider). The traefik api router should not already be
#  configured via other dynamic configuration providers.
#  
#  When False, initial dynamic configuration must be handled externally and match
#  TraefikProxy configuration, such as `traefik_api_url`, traefik_api_username`
#  and `traefik_api_password`. Choose this if the traefik api router is already
#  configured via dynamic configuration elsewhere.
#  
#  .. versionadded:: 1.1
#  Default: True
# c.TraefikProxy.enable_setup_dynamic_config = True

## Extra dynamic configuration for treafik.
#  
#          Merged with the default dynamic config during startup.
#  
#          Always takes effect unless should_start and
#  enable_setup_dynamic_config are both False.
#  Default: {}
# c.TraefikProxy.extra_dynamic_config = {}

## 
#  See also: Proxy.extra_routes
# c.TraefikProxy.extra_routes = {}

## Extra static configuration for treafik.
#  
#          Merged with the default static config before writing to
#  `.static_config_file`.
#  
#          Has no effect if `Proxy.should_start` is False.
#  Default: {}
# c.TraefikProxy.extra_static_config = {}

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.TraefikProxy.should_start = True

## traefik's static configuration file
#  Default: 'traefik.toml'
# c.TraefikProxy.static_config_file = 'traefik.toml'

## Deprecated. Use static_config_file
#  Default: ''
# c.TraefikProxy.toml_static_config_file = ''

## The traefik entrypoint name to use for API access.
#  
#          Separate from traefik_entrypoint,
#          because this is usually only on localhost.
#  Default: 'auth_api'
# c.TraefikProxy.traefik_api_entrypoint = 'auth_api'

## The password for traefik api login
#  Default: ''
# c.TraefikProxy.traefik_api_password = ''

## traefik authenticated api endpoint url
#  Default: 'http://localhost:8099'
# c.TraefikProxy.traefik_api_url = 'http://localhost:8099'

## The username for traefik api login
#  Default: ''
# c.TraefikProxy.traefik_api_username = ''

## validate SSL certificate of traefik api endpoint
#  Default: True
# c.TraefikProxy.traefik_api_validate_cert = True

## The traefik entrypoint name to use.
#  
#          By default, will be `http` if http or `https` if https.
#  
#          If running traefik externally with your own specified entrypoint name,
#          set this value.
#  Default: ''
# c.TraefikProxy.traefik_entrypoint = ''

## Environment variables to set for the traefik process.
#  
#          Only has an effect when traefik is a subprocess (should_start=True).
#  Default: {}
# c.TraefikProxy.traefik_env = {}

## traefik's log level
#  Default: ''
# c.TraefikProxy.traefik_log_level = ''

## throttle traefik reloads of configuration.
#  
#  When traefik sees a change in configuration, it will wait this long before
#  applying the next one. This affects how long adding a user to the proxy will
#  take.
#  
#  See https://doc.traefik.io/traefik/providers/overview/#providersprovidersthrot
#  tleduration
#  Default: '0s'
# c.TraefikProxy.traefik_providers_throttle_duration = '0s'

#------------------------------------------------------------------------------
# TKvProxy(TraefikProxy) configuration
#------------------------------------------------------------------------------
## JupyterHub Proxy implementation using traefik and a key-value store.
#  
#  Custom proxy implementations based on traefik and a key-value store can
#  sublass :class:`TKvProxy`.

## Timeout (in seconds) when waiting for traefik to register an updated route.
#  See also: TraefikProxy.check_route_timeout
# c.TKvProxy.check_route_timeout = 30

## 
#  See also: TraefikProxy.concurrency
# c.TKvProxy.concurrency = 10

## 
#  See also: TraefikProxy.enable_setup_dynamic_config
# c.TKvProxy.enable_setup_dynamic_config = True

## Extra dynamic configuration for treafik.
#  See also: TraefikProxy.extra_dynamic_config
# c.TKvProxy.extra_dynamic_config = {}

## 
#  See also: Proxy.extra_routes
# c.TKvProxy.extra_routes = {}

## Extra static configuration for treafik.
#  See also: TraefikProxy.extra_static_config
# c.TKvProxy.extra_static_config = {}

## The key value store key prefix for traefik dynamic configuration
#  Default: 'jupyterhub'
# c.TKvProxy.kv_jupyterhub_prefix = 'jupyterhub'

## The separator used for the path in the KV store
#  Default: '/'
# c.TKvProxy.kv_separator = '/'

## The key value store key prefix for traefik static configuration
#  Default: 'traefik'
# c.TKvProxy.kv_traefik_prefix = 'traefik'

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.TKvProxy.should_start = True

## traefik's static configuration file
#  See also: TraefikProxy.static_config_file
# c.TKvProxy.static_config_file = 'traefik.toml'

## Deprecated. Use static_config_file
#  See also: TraefikProxy.toml_static_config_file
# c.TKvProxy.toml_static_config_file = ''

## The traefik entrypoint name to use for API access.
#  See also: TraefikProxy.traefik_api_entrypoint
# c.TKvProxy.traefik_api_entrypoint = 'auth_api'

## The password for traefik api login
#  See also: TraefikProxy.traefik_api_password
# c.TKvProxy.traefik_api_password = ''

## traefik authenticated api endpoint url
#  See also: TraefikProxy.traefik_api_url
# c.TKvProxy.traefik_api_url = 'http://localhost:8099'

## The username for traefik api login
#  See also: TraefikProxy.traefik_api_username
# c.TKvProxy.traefik_api_username = ''

## validate SSL certificate of traefik api endpoint
#  See also: TraefikProxy.traefik_api_validate_cert
# c.TKvProxy.traefik_api_validate_cert = True

## The traefik entrypoint name to use.
#  See also: TraefikProxy.traefik_entrypoint
# c.TKvProxy.traefik_entrypoint = ''

## Environment variables to set for the traefik process.
#  See also: TraefikProxy.traefik_env
# c.TKvProxy.traefik_env = {}

## traefik's log level
#  See also: TraefikProxy.traefik_log_level
# c.TKvProxy.traefik_log_level = ''

## 
#  See also: TraefikProxy.traefik_providers_throttle_duration
# c.TKvProxy.traefik_providers_throttle_duration = '0s'

#------------------------------------------------------------------------------
# TraefikRedisProxy(TKvProxy) configuration
#------------------------------------------------------------------------------
## JupyterHub Proxy implementation using traefik and redis

## Timeout (in seconds) when waiting for traefik to register an updated route.
#  See also: TraefikProxy.check_route_timeout
# c.TraefikRedisProxy.check_route_timeout = 30

## 
#  See also: TraefikProxy.concurrency
# c.TraefikRedisProxy.concurrency = 10

## 
#  See also: TraefikProxy.enable_setup_dynamic_config
# c.TraefikRedisProxy.enable_setup_dynamic_config = True

## Extra dynamic configuration for treafik.
#  See also: TraefikProxy.extra_dynamic_config
# c.TraefikRedisProxy.extra_dynamic_config = {}

## 
#  See also: Proxy.extra_routes
# c.TraefikRedisProxy.extra_routes = {}

## Extra static configuration for treafik.
#  See also: TraefikProxy.extra_static_config
# c.TraefikRedisProxy.extra_static_config = {}

## The key value store key prefix for traefik dynamic configuration
#  See also: TKvProxy.kv_jupyterhub_prefix
# c.TraefikRedisProxy.kv_jupyterhub_prefix = 'jupyterhub'

## The separator used for the path in the KV store
#  See also: TKvProxy.kv_separator
# c.TraefikRedisProxy.kv_separator = '/'

## The key value store key prefix for traefik static configuration
#  See also: TKvProxy.kv_traefik_prefix
# c.TraefikRedisProxy.kv_traefik_prefix = 'traefik'

## Additional keyword arguments to pass through to the `redis.asyncio.Redis`
#  constructor
#  Default: {}
# c.TraefikRedisProxy.redis_client_kwargs = {}

## The redis password
#  Default: ''
# c.TraefikRedisProxy.redis_password = ''

## The URL for the redis endpoint
#  Default: 'redis://localhost:6379'
# c.TraefikRedisProxy.redis_url = 'redis://localhost:6379'

## The redis username
#  Default: ''
# c.TraefikRedisProxy.redis_username = ''

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.TraefikRedisProxy.should_start = True

## traefik's static configuration file
#  See also: TraefikProxy.static_config_file
# c.TraefikRedisProxy.static_config_file = 'traefik.toml'

## Deprecated. Use static_config_file
#  See also: TraefikProxy.toml_static_config_file
# c.TraefikRedisProxy.toml_static_config_file = ''

## The traefik entrypoint name to use for API access.
#  See also: TraefikProxy.traefik_api_entrypoint
# c.TraefikRedisProxy.traefik_api_entrypoint = 'auth_api'

## The password for traefik api login
#  See also: TraefikProxy.traefik_api_password
# c.TraefikRedisProxy.traefik_api_password = ''

## traefik authenticated api endpoint url
#  See also: TraefikProxy.traefik_api_url
# c.TraefikRedisProxy.traefik_api_url = 'http://localhost:8099'

## The username for traefik api login
#  See also: TraefikProxy.traefik_api_username
# c.TraefikRedisProxy.traefik_api_username = ''

## validate SSL certificate of traefik api endpoint
#  See also: TraefikProxy.traefik_api_validate_cert
# c.TraefikRedisProxy.traefik_api_validate_cert = True

## The traefik entrypoint name to use.
#  See also: TraefikProxy.traefik_entrypoint
# c.TraefikRedisProxy.traefik_entrypoint = ''

## Environment variables to set for the traefik process.
#  See also: TraefikProxy.traefik_env
# c.TraefikRedisProxy.traefik_env = {}

## traefik's log level
#  See also: TraefikProxy.traefik_log_level
# c.TraefikRedisProxy.traefik_log_level = ''

## 
#  See also: TraefikProxy.traefik_providers_throttle_duration
# c.TraefikRedisProxy.traefik_providers_throttle_duration = '0s'

#------------------------------------------------------------------------------
# GenericOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: OAuthenticator.admin_groups
# c.GenericOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.GenericOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.GenericOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.GenericOAuthenticator.allow_existing_users = False

## 
#  See also: OAuthenticator.allowed_groups
# c.GenericOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.GenericOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.GenericOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.GenericOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.GenericOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.GenericOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.GenericOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.GenericOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.GenericOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.GenericOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.GenericOAuthenticator.blocked_users = set()

## .. deprecated:: 17.0
#  
#  Use :attr:`auth_state_groups_key` instead.
#  
#  .. versionchanged:: 17.0
#  
#  :attr:`manage_groups` is now required to be `True` to use this functionality
#  Default: traitlets.Undefined
# c.GenericOAuthenticator.claim_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.client_id
# c.GenericOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.GenericOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.GenericOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.GenericOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.GenericOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.GenericOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.GenericOAuthenticator.extra_authorize_params = {}

## .. deprecated:: 16.0
#  
#     Use :attr:`token_params`.
#  Default: {}
# c.GenericOAuthenticator.extra_params = {}

## 
#  See also: OAuthenticator.http_request_kwargs
# c.GenericOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.GenericOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.GenericOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.GenericOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.GenericOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.GenericOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.GenericOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.GenericOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.GenericOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.GenericOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.GenericOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.GenericOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.GenericOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.GenericOAuthenticator.scope = []

## .. deprecated:: 16.0
#  
#     Use :attr:`validate_server_cert`.
#  Default: False
# c.GenericOAuthenticator.tls_verify = False

## 
#  See also: OAuthenticator.token_params
# c.GenericOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.GenericOAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.GenericOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.GenericOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.GenericOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.GenericOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.GenericOAuthenticator.username_claim = traitlets.Undefined

## .. deprecated:: 16.0
#  
#     Use :attr:`username_claim`.
#  Default: traitlets.Undefined
# c.GenericOAuthenticator.username_key = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.GenericOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.GenericOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.GenericOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.GenericOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalGenericOAuthenticator(LocalAuthenticator, GenericOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalGenericOAuthenticator.add_user_cmd = []

## 
#  See also: OAuthenticator.admin_groups
# c.LocalGenericOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalGenericOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalGenericOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalGenericOAuthenticator.allow_existing_users = False

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalGenericOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalGenericOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalGenericOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalGenericOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalGenericOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalGenericOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalGenericOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalGenericOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalGenericOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalGenericOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalGenericOAuthenticator.blocked_users = set()

## 
#  See also: GenericOAuthenticator.claim_groups_key
# c.LocalGenericOAuthenticator.claim_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.client_id
# c.LocalGenericOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalGenericOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalGenericOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalGenericOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalGenericOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalGenericOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalGenericOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalGenericOAuthenticator.extra_authorize_params = {}

## 
#  See also: GenericOAuthenticator.extra_params
# c.LocalGenericOAuthenticator.extra_params = {}

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalGenericOAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalGenericOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.LocalGenericOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalGenericOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalGenericOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalGenericOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalGenericOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalGenericOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalGenericOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalGenericOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalGenericOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalGenericOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalGenericOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalGenericOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.LocalGenericOAuthenticator.scope = []

## 
#  See also: GenericOAuthenticator.tls_verify
# c.LocalGenericOAuthenticator.tls_verify = False

## 
#  See also: OAuthenticator.token_params
# c.LocalGenericOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalGenericOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalGenericOAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalGenericOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalGenericOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalGenericOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalGenericOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalGenericOAuthenticator.username_claim = traitlets.Undefined

## 
#  See also: GenericOAuthenticator.username_key
# c.LocalGenericOAuthenticator.username_key = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalGenericOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalGenericOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalGenericOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalGenericOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# TraefikFileProviderProxy(TraefikProxy) configuration
#------------------------------------------------------------------------------
## JupyterHub Proxy implementation using traefik and toml or yaml config file

## Timeout (in seconds) when waiting for traefik to register an updated route.
#  See also: TraefikProxy.check_route_timeout
# c.TraefikFileProviderProxy.check_route_timeout = 30

## 
#  See also: TraefikProxy.concurrency
# c.TraefikFileProviderProxy.concurrency = 10

## traefik's dynamic configuration file
#  Default: 'rules.toml'
# c.TraefikFileProviderProxy.dynamic_config_file = 'rules.toml'

## 
#  See also: TraefikProxy.enable_setup_dynamic_config
# c.TraefikFileProviderProxy.enable_setup_dynamic_config = True

## Extra dynamic configuration for treafik.
#  See also: TraefikProxy.extra_dynamic_config
# c.TraefikFileProviderProxy.extra_dynamic_config = {}

## 
#  See also: Proxy.extra_routes
# c.TraefikFileProviderProxy.extra_routes = {}

## Extra static configuration for treafik.
#  See also: TraefikProxy.extra_static_config
# c.TraefikFileProviderProxy.extra_static_config = {}

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.TraefikFileProviderProxy.should_start = True

## traefik's static configuration file
#  See also: TraefikProxy.static_config_file
# c.TraefikFileProviderProxy.static_config_file = 'traefik.toml'

## Deprecated. Use static_config_file
#  See also: TraefikProxy.toml_static_config_file
# c.TraefikFileProviderProxy.toml_static_config_file = ''

## The traefik entrypoint name to use for API access.
#  See also: TraefikProxy.traefik_api_entrypoint
# c.TraefikFileProviderProxy.traefik_api_entrypoint = 'auth_api'

## The password for traefik api login
#  See also: TraefikProxy.traefik_api_password
# c.TraefikFileProviderProxy.traefik_api_password = ''

## traefik authenticated api endpoint url
#  See also: TraefikProxy.traefik_api_url
# c.TraefikFileProviderProxy.traefik_api_url = 'http://localhost:8099'

## The username for traefik api login
#  See also: TraefikProxy.traefik_api_username
# c.TraefikFileProviderProxy.traefik_api_username = ''

## validate SSL certificate of traefik api endpoint
#  See also: TraefikProxy.traefik_api_validate_cert
# c.TraefikFileProviderProxy.traefik_api_validate_cert = True

## The traefik entrypoint name to use.
#  See also: TraefikProxy.traefik_entrypoint
# c.TraefikFileProviderProxy.traefik_entrypoint = ''

## Environment variables to set for the traefik process.
#  See also: TraefikProxy.traefik_env
# c.TraefikFileProviderProxy.traefik_env = {}

## traefik's log level
#  See also: TraefikProxy.traefik_log_level
# c.TraefikFileProviderProxy.traefik_log_level = ''

## 
#  See also: TraefikProxy.traefik_providers_throttle_duration
# c.TraefikFileProviderProxy.traefik_providers_throttle_duration = '0s'

#------------------------------------------------------------------------------
# TraefikTomlProxy(TraefikFileProviderProxy) configuration
#------------------------------------------------------------------------------
## Deprecated alias for file provider

## Timeout (in seconds) when waiting for traefik to register an updated route.
#  See also: TraefikProxy.check_route_timeout
# c.TraefikTomlProxy.check_route_timeout = 30

## 
#  See also: TraefikProxy.concurrency
# c.TraefikTomlProxy.concurrency = 10

## traefik's dynamic configuration file
#  See also: TraefikFileProviderProxy.dynamic_config_file
# c.TraefikTomlProxy.dynamic_config_file = 'rules.toml'

## 
#  See also: TraefikProxy.enable_setup_dynamic_config
# c.TraefikTomlProxy.enable_setup_dynamic_config = True

## Extra dynamic configuration for treafik.
#  See also: TraefikProxy.extra_dynamic_config
# c.TraefikTomlProxy.extra_dynamic_config = {}

## 
#  See also: Proxy.extra_routes
# c.TraefikTomlProxy.extra_routes = {}

## Extra static configuration for treafik.
#  See also: TraefikProxy.extra_static_config
# c.TraefikTomlProxy.extra_static_config = {}

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.TraefikTomlProxy.should_start = True

## traefik's static configuration file
#  See also: TraefikProxy.static_config_file
# c.TraefikTomlProxy.static_config_file = 'traefik.toml'

#  Default: ''
# c.TraefikTomlProxy.toml_dynamic_config_file = ''

## Deprecated. Use static_config_file
#  See also: TraefikProxy.toml_static_config_file
# c.TraefikTomlProxy.toml_static_config_file = ''

## The traefik entrypoint name to use for API access.
#  See also: TraefikProxy.traefik_api_entrypoint
# c.TraefikTomlProxy.traefik_api_entrypoint = 'auth_api'

## The password for traefik api login
#  See also: TraefikProxy.traefik_api_password
# c.TraefikTomlProxy.traefik_api_password = ''

## traefik authenticated api endpoint url
#  See also: TraefikProxy.traefik_api_url
# c.TraefikTomlProxy.traefik_api_url = 'http://localhost:8099'

## The username for traefik api login
#  See also: TraefikProxy.traefik_api_username
# c.TraefikTomlProxy.traefik_api_username = ''

## validate SSL certificate of traefik api endpoint
#  See also: TraefikProxy.traefik_api_validate_cert
# c.TraefikTomlProxy.traefik_api_validate_cert = True

## The traefik entrypoint name to use.
#  See also: TraefikProxy.traefik_entrypoint
# c.TraefikTomlProxy.traefik_entrypoint = ''

## Environment variables to set for the traefik process.
#  See also: TraefikProxy.traefik_env
# c.TraefikTomlProxy.traefik_env = {}

## traefik's log level
#  See also: TraefikProxy.traefik_log_level
# c.TraefikTomlProxy.traefik_log_level = ''

## 
#  See also: TraefikProxy.traefik_providers_throttle_duration
# c.TraefikTomlProxy.traefik_providers_throttle_duration = '0s'

#------------------------------------------------------------------------------
# NullAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## Null Authenticator for JupyterHub
#  
#      For cases where authentication should be disabled,
#      e.g. only allowing access via API tokens.
#  
#      .. versionadded:: 2.0

## 
#  See also: Authenticator.admin_users
# c.NullAuthenticator.admin_users = set()

## 
#  See also: Authenticator.allow_all
# c.NullAuthenticator.allow_all = False

## 
#  See also: Authenticator.allow_existing_users
# c.NullAuthenticator.allow_existing_users = False

## 
#  See also: Authenticator.allowed_users
# c.NullAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.NullAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.NullAuthenticator.auth_refresh_age = 300

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.NullAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: Authenticator.blocked_users
# c.NullAuthenticator.blocked_users = set()

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.NullAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.NullAuthenticator.enable_auth_state = False

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.NullAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.NullAuthenticator.manage_roles = False

## 
#  See also: Authenticator.otp_prompt
# c.NullAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.NullAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.NullAuthenticator.refresh_pre_spawn = False

## 
#  See also: Authenticator.request_otp
# c.NullAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.NullAuthenticator.reset_managed_roles_on_startup = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.NullAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.NullAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.NullAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# SimpleLocalProcessSpawner(LocalProcessSpawner) configuration
#------------------------------------------------------------------------------
## A version of LocalProcessSpawner that doesn't require users to exist on the
#  system beforehand.
#  
#  Only use this for testing.
#  
#  Note: DO NOT USE THIS FOR PRODUCTION USE CASES! It is very insecure, and
#  provides absolutely no isolation between different users!

## 
#  See also: Spawner.args
# c.SimpleLocalProcessSpawner.args = []

## 
#  See also: Spawner.auth_state_hook
# c.SimpleLocalProcessSpawner.auth_state_hook = None

## 
#  See also: Spawner.cmd
# c.SimpleLocalProcessSpawner.cmd = ['jupyterhub-singleuser']

## 
#  See also: Spawner.consecutive_failure_limit
# c.SimpleLocalProcessSpawner.consecutive_failure_limit = 0

## 
#  See also: Spawner.cpu_guarantee
# c.SimpleLocalProcessSpawner.cpu_guarantee = None

## 
#  See also: Spawner.cpu_limit
# c.SimpleLocalProcessSpawner.cpu_limit = None

## Enable debug-logging of the single-user server
#  See also: Spawner.debug
# c.SimpleLocalProcessSpawner.debug = False

## 
#  See also: Spawner.default_url
# c.SimpleLocalProcessSpawner.default_url = ''

## 
#  See also: Spawner.disable_user_config
# c.SimpleLocalProcessSpawner.disable_user_config = False

## 
#  See also: Spawner.env_keep
# c.SimpleLocalProcessSpawner.env_keep = ['JUPYTERHUB_SINGLEUSER_APP']

## 
#  See also: Spawner.environment
# c.SimpleLocalProcessSpawner.environment = {}

## 
#  See also: Spawner.group_overrides
# c.SimpleLocalProcessSpawner.group_overrides = traitlets.Undefined

## Template to expand to set the user home. {username} is expanded to the
#  jupyterhub username.
#  Default: '/tmp/{username}'
# c.SimpleLocalProcessSpawner.home_dir_template = '/tmp/{username}'

## 
#  See also: Spawner.http_timeout
# c.SimpleLocalProcessSpawner.http_timeout = 30

## 
#  See also: Spawner.hub_connect_url
# c.SimpleLocalProcessSpawner.hub_connect_url = None

## 
#  See also: LocalProcessSpawner.interrupt_timeout
# c.SimpleLocalProcessSpawner.interrupt_timeout = 10

## 
#  See also: Spawner.ip
# c.SimpleLocalProcessSpawner.ip = '127.0.0.1'

## 
#  See also: LocalProcessSpawner.kill_timeout
# c.SimpleLocalProcessSpawner.kill_timeout = 5

## 
#  See also: Spawner.mem_guarantee
# c.SimpleLocalProcessSpawner.mem_guarantee = None

## 
#  See also: Spawner.mem_limit
# c.SimpleLocalProcessSpawner.mem_limit = None

## 
#  See also: Spawner.notebook_dir
# c.SimpleLocalProcessSpawner.notebook_dir = ''

## Allowed scopes for oauth tokens issued by this server's oauth client.
#  See also: Spawner.oauth_client_allowed_scopes
# c.SimpleLocalProcessSpawner.oauth_client_allowed_scopes = traitlets.Undefined

## Allowed roles for oauth tokens.
#  See also: Spawner.oauth_roles
# c.SimpleLocalProcessSpawner.oauth_roles = traitlets.Undefined

## 
#  See also: Spawner.options_form
# c.SimpleLocalProcessSpawner.options_form = traitlets.Undefined

## 
#  See also: Spawner.options_from_form
# c.SimpleLocalProcessSpawner.options_from_form = traitlets.Undefined

## 
#  See also: Spawner.poll_interval
# c.SimpleLocalProcessSpawner.poll_interval = 30

## 
#  See also: Spawner.poll_jitter
# c.SimpleLocalProcessSpawner.poll_jitter = 0.1

## Extra keyword arguments to pass to Popen
#  See also: LocalProcessSpawner.popen_kwargs
# c.SimpleLocalProcessSpawner.popen_kwargs = {}

## 
#  See also: Spawner.port
# c.SimpleLocalProcessSpawner.port = 0

## 
#  See also: Spawner.post_stop_hook
# c.SimpleLocalProcessSpawner.post_stop_hook = None

## 
#  See also: Spawner.pre_spawn_hook
# c.SimpleLocalProcessSpawner.pre_spawn_hook = None

## 
#  See also: Spawner.progress_ready_hook
# c.SimpleLocalProcessSpawner.progress_ready_hook = None

## The list of scopes to request for $JUPYTERHUB_API_TOKEN
#  See also: Spawner.server_token_scopes
# c.SimpleLocalProcessSpawner.server_token_scopes = traitlets.Undefined

## Specify a shell command to launch.
#  See also: LocalProcessSpawner.shell_cmd
# c.SimpleLocalProcessSpawner.shell_cmd = []

## List of SSL alt names
#  See also: Spawner.ssl_alt_names
# c.SimpleLocalProcessSpawner.ssl_alt_names = []

## Whether to include `DNS:localhost`, `IP:127.0.0.1` in alt names
#  See also: Spawner.ssl_alt_names_include_local
# c.SimpleLocalProcessSpawner.ssl_alt_names_include_local = True

## 
#  See also: Spawner.start_timeout
# c.SimpleLocalProcessSpawner.start_timeout = 60

## 
#  See also: LocalProcessSpawner.term_timeout
# c.SimpleLocalProcessSpawner.term_timeout = 5

#------------------------------------------------------------------------------
# CILogonOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## .. versionremoved:: 16.0
#  
#     Use :attr:`allowed_idps`.
#  Default: []
# c.CILogonOAuthenticator.additional_username_claims = []

## 
#  See also: OAuthenticator.admin_groups
# c.CILogonOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.CILogonOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.CILogonOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.CILogonOAuthenticator.allow_existing_users = False

## 
#  See also: OAuthenticator.allowed_groups
# c.CILogonOAuthenticator.allowed_groups = set()

## A dictionary of the only entity IDs that will be allowed to be used as login
#  options. See https://cilogon.org/idplist for the list of `EntityIDs` of each
#  IdP.
#  
#  It can be used to enable domain stripping, adding prefixes to the usernames
#  and to specify an identity provider specific username claim.
#  
#  For example::
#  
#      c.CILogonOAuthenticator.allowed_idps = {
#          "https://idpz.utorauth.utoronto.ca/shibboleth": {
#              "username_derivation": {
#                  "username_claim": "email",
#                  "action": "strip_idp_domain",
#                  "domain": "utoronto.ca",
#              },
#              "allow_all": True,
#              "default": True,
#          },
#          "http://google.com/accounts/o8/id": {
#              "username_derivation": {
#                  "username_claim": "email",
#                  "action": "prefix",
#                  "prefix": "google",
#              },
#              "allowed_domains": ["uni.edu", "something.org"],
#          },
#          "https://github.com/login/oauth/authorize": {
#              "username_derivation": {
#                  "username_claim": "preferred_username",
#                  "action": "prefix",
#                  "prefix": "github",
#              },
#              # allow_all or allowed_domains not specified for ths idp,
#              # this means that its users must be explicitly allowed
#              # with a config such as allowed_users or admin_users.
#          },
#      }
#      c.Authenticator.admin_users = ["github-user1"]
#      c.Authenticator.allowed_users = ["github-user2"]
#  
#  This is a description of the configuration you can pass to `allowed_idps`.
#  
#  * `default`: bool (optional)
#      Determines the identity provider to be pre-selected in a list for
#      users arriving to CILogons login screen.
#  * `username_derivation`: string (required)
#      * `username_claim`: string (required)
#          The claim in the `userinfo` response from which to define the
#          JupyterHub username. Examples include: `eppn`, `email`. What
#          keys are available will depend on the scopes requested.
#      * `action`: string
#          What action to perform on the username. Available options are
#          "strip_idp_domain", which will strip the domain from the
#          username if specified and "prefix", which will prefix the hub
#          username with "prefix:".
#      * `domain:` string (required if action is strip_idp_domain)
#          The domain after "@" which will be stripped from the username if
#          it exists and if the action is "strip_idp_domain".
#      * `prefix`: string (required if action is prefix)
#          The prefix which will be added at the beginning of the username
#          followed by a semi-column ":", if the action is "prefix".
#  * `allow_all`: bool (defaults to False)
#      Configuring this allows all users authenticating with this identity
#      provider.
#  * `allowed_domains`: list of strings
#      Allows users associated with a listed domain to sign in.
#  
#      Use of wildcards `*` and a bit more is supported via Python's
#      `fnmatch` function since version 16.2. Setting `allowed_domains` to
#      `["jupyter.org", "*.jupyter.org"]` would for example allow users
#      with `jovyan@jupyter.org` or `jovyan@hub.jupyter.org` usernames.
#  
#      The domain the user is associated with is based on the username by
#      default in version 16, but this can be reconfigured to be based on a
#      claim in the `userinfo` response via `allowed_domains_claim`. The
#      domain is treated case insensitive and can either be directly
#      specified by the claim's value or extracted from an email string.
#  * `allowed_domains_claim`: string (optional)
#      This configuration represents the claim in the `userinfo` response
#      to identify a domain that could allow a user to sign in via
#      `allowed_domains`.
#  
#      The claim can defaults to the username claim in version 16, but this
#      will change to "email" in version 17.
#  
#      .. versionadded:: 16.2
#  
#  .. versionchanged:: 15.0
#  
#     Changed format from a list to a dictionary.
#  Default: {}
# c.CILogonOAuthenticator.allowed_idps = {}

## 
#  See also: OAuthenticator.allowed_scopes
# c.CILogonOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.CILogonOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.CILogonOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.CILogonOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.CILogonOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.CILogonOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.CILogonOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.CILogonOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.CILogonOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.CILogonOAuthenticator.blocked_users = set()

## Used to determine the default values for `authorize_url`, `token_url`, and
#  `userdata_url`.
#  Default: 'cilogon.org'
# c.CILogonOAuthenticator.cilogon_host = 'cilogon.org'

## 
#  See also: OAuthenticator.client_id
# c.CILogonOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.CILogonOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.CILogonOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.CILogonOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.CILogonOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.CILogonOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.CILogonOAuthenticator.extra_authorize_params = {}

## 
#  See also: OAuthenticator.http_request_kwargs
# c.CILogonOAuthenticator.http_request_kwargs = {}

## .. versionremoved:: 15.0
#  
#     Use :attr:`allowed_idps`.
#  Default: ''
# c.CILogonOAuthenticator.idp = ''

## .. versionremoved:: 0.12
#  
#     Use :attr:`allowed_idps`.
#  Default: []
# c.CILogonOAuthenticator.idp_whitelist = []

## 
#  See also: OAuthenticator.login_service
# c.CILogonOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.CILogonOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.CILogonOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.CILogonOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.CILogonOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.CILogonOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.CILogonOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.CILogonOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.CILogonOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.CILogonOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.CILogonOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.CILogonOAuthenticator.reset_managed_roles_on_startup = False

## OAuth scopes to request.
#  
#  `openid` and `org.cilogon.userinfo` is required.
#  
#  Read more about CILogon scopes in https://www.cilogon.org/oidc.
#  Default: ['openid', 'email', 'org.cilogon.userinfo', 'profile']
# c.CILogonOAuthenticator.scope = ['openid', 'email', 'org.cilogon.userinfo', 'profile']

## .. versionremoved:: 16.0
#  
#     Use :attr:`allowed_idps`.
#  Default: []
# c.CILogonOAuthenticator.shown_idps = []

## The `skin` attribute is the name of the custom CILogon interface skin for your
#  application.
#  
#  Contact help@cilogon.org to request a custom skin.
#  Default: ''
# c.CILogonOAuthenticator.skin = ''

## .. versionremoved:: 15.0
#  
#     Use :attr:`allowed_idps`.
#  Default: False
# c.CILogonOAuthenticator.strip_idp_domain = False

## 
#  See also: OAuthenticator.token_params
# c.CILogonOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.CILogonOAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.CILogonOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.CILogonOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.CILogonOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.CILogonOAuthenticator.userdata_url = ''

## .. versionremoved:: 16.0
#  
#     Use :attr:`allowed_idps`.
#  Default: ''
# c.CILogonOAuthenticator.username_claim = ''

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.CILogonOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.CILogonOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.CILogonOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.CILogonOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalCILogonOAuthenticator(LocalAuthenticator, CILogonOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalCILogonOAuthenticator.add_user_cmd = []

## 
#  See also: CILogonOAuthenticator.additional_username_claims
# c.LocalCILogonOAuthenticator.additional_username_claims = []

## 
#  See also: OAuthenticator.admin_groups
# c.LocalCILogonOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalCILogonOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalCILogonOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalCILogonOAuthenticator.allow_existing_users = False

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalCILogonOAuthenticator.allowed_groups = set()

## 
#  See also: CILogonOAuthenticator.allowed_idps
# c.LocalCILogonOAuthenticator.allowed_idps = {}

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalCILogonOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalCILogonOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalCILogonOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalCILogonOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalCILogonOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalCILogonOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalCILogonOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalCILogonOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalCILogonOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalCILogonOAuthenticator.blocked_users = set()

## 
#  See also: CILogonOAuthenticator.cilogon_host
# c.LocalCILogonOAuthenticator.cilogon_host = 'cilogon.org'

## 
#  See also: OAuthenticator.client_id
# c.LocalCILogonOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalCILogonOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalCILogonOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalCILogonOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalCILogonOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalCILogonOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalCILogonOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalCILogonOAuthenticator.extra_authorize_params = {}

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalCILogonOAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalCILogonOAuthenticator.http_request_kwargs = {}

## 
#  See also: CILogonOAuthenticator.idp
# c.LocalCILogonOAuthenticator.idp = ''

## 
#  See also: CILogonOAuthenticator.idp_whitelist
# c.LocalCILogonOAuthenticator.idp_whitelist = []

## 
#  See also: OAuthenticator.login_service
# c.LocalCILogonOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalCILogonOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalCILogonOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalCILogonOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalCILogonOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalCILogonOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalCILogonOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalCILogonOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalCILogonOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalCILogonOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalCILogonOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalCILogonOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: CILogonOAuthenticator.scope
# c.LocalCILogonOAuthenticator.scope = ['openid', 'email', 'org.cilogon.userinfo', 'profile']

## 
#  See also: CILogonOAuthenticator.shown_idps
# c.LocalCILogonOAuthenticator.shown_idps = []

## 
#  See also: CILogonOAuthenticator.skin
# c.LocalCILogonOAuthenticator.skin = ''

## 
#  See also: CILogonOAuthenticator.strip_idp_domain
# c.LocalCILogonOAuthenticator.strip_idp_domain = False

## 
#  See also: OAuthenticator.token_params
# c.LocalCILogonOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalCILogonOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalCILogonOAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalCILogonOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalCILogonOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalCILogonOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalCILogonOAuthenticator.userdata_url = ''

## 
#  See also: CILogonOAuthenticator.username_claim
# c.LocalCILogonOAuthenticator.username_claim = ''

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalCILogonOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalCILogonOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalCILogonOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalCILogonOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# PAMAuthenticator(LocalAuthenticator) configuration
#------------------------------------------------------------------------------
## Authenticate local UNIX users with PAM

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.PAMAuthenticator.add_user_cmd = []

## Authoritative list of user groups that determine admin access. Users not in
#  these groups can still be granted admin status through admin_users.
#  
#  allowed/blocked rules still apply.
#  
#  Note: As of JupyterHub 2.0, full admin rights should not be required, and more
#  precise permissions can be managed via roles.
#  Default: set()
# c.PAMAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.PAMAuthenticator.admin_users = set()

## 
#  See also: Authenticator.allow_all
# c.PAMAuthenticator.allow_all = False

## 
#  See also: Authenticator.allow_existing_users
# c.PAMAuthenticator.allow_existing_users = False

## 
#  See also: LocalAuthenticator.allowed_groups
# c.PAMAuthenticator.allowed_groups = set()

## 
#  See also: Authenticator.allowed_users
# c.PAMAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.PAMAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.PAMAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.PAMAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.PAMAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: Authenticator.blocked_users
# c.PAMAuthenticator.blocked_users = set()

## Whether to check the user's account status via PAM during authentication.
#  
#  The PAM account stack performs non-authentication based account management. It
#  is typically used to restrict/permit access to a service and this step is
#  needed to access the host's user access control.
#  
#  Disabling this can be dangerous as authenticated but unauthorized users may be
#  granted access and, therefore, arbitrary execution on the system.
#  Default: True
# c.PAMAuthenticator.check_account = True

## 
#  See also: LocalAuthenticator.create_system_users
# c.PAMAuthenticator.create_system_users = False

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.PAMAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.PAMAuthenticator.enable_auth_state = False

## The text encoding to use when communicating with PAM
#  Default: 'utf8'
# c.PAMAuthenticator.encoding = 'utf8'

## Number of executor threads.
#  
#  PAM auth requests happen in this thread, so it is mostly waiting for the pam
#  stack. One thread is usually enough, unless your pam stack is doing something
#  slow like network requests
#  Default: 4
# c.PAMAuthenticator.executor_threads = 4

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.PAMAuthenticator.group_whitelist = set()

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.PAMAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.PAMAuthenticator.manage_roles = False

## Whether to open a new PAM session when spawners are started.
#  
#  This may trigger things like mounting shared filesystems, loading credentials,
#  etc. depending on system configuration.
#  
#  The lifecycle of PAM sessions is not correct, so many PAM session
#  configurations will not work.
#  
#  If any errors are encountered when opening/closing PAM sessions, this is
#  automatically set to False.
#  
#  .. versionchanged:: 2.2
#  
#      Due to longstanding problems in the session lifecycle,
#      this is now disabled by default.
#      You may opt-in to opening sessions by setting this to True.
#  Default: False
# c.PAMAuthenticator.open_sessions = False

## 
#  See also: Authenticator.otp_prompt
# c.PAMAuthenticator.otp_prompt = 'OTP:'

## Round-trip the username via PAM lookups to make sure it is unique
#  
#  PAM can accept multiple usernames that map to the same user, for example
#  DOMAIN\username in some cases.  To prevent this, convert username into uid,
#  then back to uid to normalize.
#  Default: False
# c.PAMAuthenticator.pam_normalize_username = False

## 
#  See also: Authenticator.post_auth_hook
# c.PAMAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.PAMAuthenticator.refresh_pre_spawn = False

## 
#  See also: Authenticator.request_otp
# c.PAMAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.PAMAuthenticator.reset_managed_roles_on_startup = False

## The name of the PAM service to use for authentication
#  Default: 'login'
# c.PAMAuthenticator.service = 'login'

## 
#  See also: LocalAuthenticator.uids
# c.PAMAuthenticator.uids = {}

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.PAMAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.PAMAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.PAMAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# CryptKeeper(SingletonConfigurable) configuration
#------------------------------------------------------------------------------
## Encapsulate encryption configuration
#  
#      Use via the encryption_config singleton below.

#  Default: []
# c.CryptKeeper.keys = []

## The number of threads to allocate for encryption
#  Default: 8
# c.CryptKeeper.n_threads = 8

#------------------------------------------------------------------------------
# LocalAzureAdOAuthenticator(LocalAuthenticator, AzureAdOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalAzureAdOAuthenticator.add_user_cmd = []

## 
#  See also: OAuthenticator.admin_groups
# c.LocalAzureAdOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalAzureAdOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalAzureAdOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalAzureAdOAuthenticator.allow_existing_users = False

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalAzureAdOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalAzureAdOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalAzureAdOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalAzureAdOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalAzureAdOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalAzureAdOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalAzureAdOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalAzureAdOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalAzureAdOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalAzureAdOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalAzureAdOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.LocalAzureAdOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalAzureAdOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalAzureAdOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalAzureAdOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalAzureAdOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalAzureAdOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalAzureAdOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalAzureAdOAuthenticator.extra_authorize_params = {}

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalAzureAdOAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalAzureAdOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.LocalAzureAdOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalAzureAdOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalAzureAdOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalAzureAdOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalAzureAdOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalAzureAdOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalAzureAdOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalAzureAdOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalAzureAdOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalAzureAdOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalAzureAdOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalAzureAdOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.LocalAzureAdOAuthenticator.scope = []

## 
#  See also: AzureAdOAuthenticator.tenant_id
# c.LocalAzureAdOAuthenticator.tenant_id = ''

## 
#  See also: OAuthenticator.token_params
# c.LocalAzureAdOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalAzureAdOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalAzureAdOAuthenticator.uids = {}

## 
#  See also: AzureAdOAuthenticator.user_groups_claim
# c.LocalAzureAdOAuthenticator.user_groups_claim = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalAzureAdOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalAzureAdOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalAzureAdOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalAzureAdOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalAzureAdOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalAzureAdOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalAzureAdOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalAzureAdOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalAzureAdOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# DummyAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## Dummy Authenticator for testing
#  
#      By default, any username + password is allowed
#      If a non-empty password is set, any username will be allowed
#      if it logs in with that password.
#  
#      .. versionadded:: 1.0
#  
#      .. versionadded:: 5.0
#          `allow_all` defaults to True,
#          preserving default behavior.

## 
#  See also: Authenticator.admin_users
# c.DummyAuthenticator.admin_users = set()

## 
#  See also: Authenticator.allow_all
# c.DummyAuthenticator.allow_all = False

## 
#  See also: Authenticator.allow_existing_users
# c.DummyAuthenticator.allow_existing_users = False

## 
#  See also: Authenticator.allowed_users
# c.DummyAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.DummyAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.DummyAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.DummyAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.DummyAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: Authenticator.blocked_users
# c.DummyAuthenticator.blocked_users = set()

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.DummyAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.DummyAuthenticator.enable_auth_state = False

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.DummyAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.DummyAuthenticator.manage_roles = False

## 
#  See also: Authenticator.otp_prompt
# c.DummyAuthenticator.otp_prompt = 'OTP:'

## Set a global password for all users wanting to log in.
#  
#  This allows users with any username to log in with the same static password.
#  Default: ''
# c.DummyAuthenticator.password = ''

## 
#  See also: Authenticator.post_auth_hook
# c.DummyAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.DummyAuthenticator.refresh_pre_spawn = False

## 
#  See also: Authenticator.request_otp
# c.DummyAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.DummyAuthenticator.reset_managed_roles_on_startup = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.DummyAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.DummyAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.DummyAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# OpenShiftOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: OAuthenticator.admin_groups
# c.OpenShiftOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.OpenShiftOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.OpenShiftOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.OpenShiftOAuthenticator.allow_existing_users = False

## 
#  See also: OAuthenticator.allowed_groups
# c.OpenShiftOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.OpenShiftOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.OpenShiftOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.OpenShiftOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.OpenShiftOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.OpenShiftOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.OpenShiftOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.OpenShiftOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.OpenShiftOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.OpenShiftOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.OpenShiftOAuthenticator.blocked_users = set()

## .. versionremoved:: 16.0
#  
#     Use :attr:`http_request_kwargs`.
#  Default: ''
# c.OpenShiftOAuthenticator.ca_certs = ''

## 
#  See also: OAuthenticator.client_id
# c.OpenShiftOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.OpenShiftOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.OpenShiftOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.OpenShiftOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.OpenShiftOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.OpenShiftOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.OpenShiftOAuthenticator.extra_authorize_params = {}

## 
#  See also: OAuthenticator.http_request_kwargs
# c.OpenShiftOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.OpenShiftOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.OpenShiftOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.OpenShiftOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.OpenShiftOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.OpenShiftOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.OpenShiftOAuthenticator.oauth_callback_url = ''

## Used to determine the default values for `authorize_url` and `token_url`.
#  
#  By default, this is determined on startup by a request to the `openshift_url`
#  appended with "/.well-known/oauth-authorization-server", where "issuer" is
#  extracted from the response.
#  
#  For more context, see the `Obtaining Authorization Server Metadata section
#  <https://datatracker.ietf.org/doc/html/rfc8414#section-3>`_ in an OAuth2
#  standard document.
#  Default: ''
# c.OpenShiftOAuthenticator.openshift_auth_api_url = ''

## Used to determine the default value for `userdata_url`.
#  
#  Defaults to the `openshift_url`.
#  Default: ''
# c.OpenShiftOAuthenticator.openshift_rest_api_url = ''

## Used to determine the default values for `openshift_auth_api_url` and
#  `openshift_rest_api_url`.
#  Default: 'https://openshift.default.svc.cluster.local'
# c.OpenShiftOAuthenticator.openshift_url = 'https://openshift.default.svc.cluster.local'

## 
#  See also: Authenticator.otp_prompt
# c.OpenShiftOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.OpenShiftOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.OpenShiftOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.OpenShiftOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.OpenShiftOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.OpenShiftOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.OpenShiftOAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.OpenShiftOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.OpenShiftOAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.OpenShiftOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.OpenShiftOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.OpenShiftOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.OpenShiftOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.OpenShiftOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.OpenShiftOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.OpenShiftOAuthenticator.username_pattern = ''

## .. deprecated:: 16.0
#  
#     Use :attr:`validate_server_cert`.
#  Default: False
# c.OpenShiftOAuthenticator.validate_cert = False

## 
#  See also: OAuthenticator.validate_server_cert
# c.OpenShiftOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.OpenShiftOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# ConfigurableHTTPProxy(Proxy) configuration
#------------------------------------------------------------------------------
## Proxy implementation for the default configurable-http-proxy.
#  
#      This is the default proxy implementation
#      for running the nodejs proxy `configurable-http-proxy`.
#  
#      If the proxy should not be run as a subprocess of the Hub,
#      (e.g. in a separate container),
#      set::
#  
#          c.ConfigurableHTTPProxy.should_start = False

## The ip (or hostname) of the proxy's API endpoint
#  Default: ''
# c.ConfigurableHTTPProxy.api_url = ''

## The Proxy auth token
#  
#          Loaded from the CONFIGPROXY_AUTH_TOKEN env variable by default.
#  Default: ''
# c.ConfigurableHTTPProxy.auth_token = ''

## Interval (in seconds) at which to check if the proxy is running.
#  Default: 5
# c.ConfigurableHTTPProxy.check_running_interval = 5

## The command to start the proxy
#  Default: ['configurable-http-proxy']
# c.ConfigurableHTTPProxy.command = ['configurable-http-proxy']

## The number of requests allowed to be concurrently outstanding to the proxy
#  
#  Limiting this number avoids potential timeout errors by sending too many
#  requests to update the proxy at once
#  Default: 10
# c.ConfigurableHTTPProxy.concurrency = 10

## Add debug-level logging to the Proxy.
#  Default: False
# c.ConfigurableHTTPProxy.debug = False

## 
#  See also: Proxy.extra_routes
# c.ConfigurableHTTPProxy.extra_routes = {}

## Proxy log level
#  Choices: any of ['debug', 'info', 'warn', 'error'] (case-insensitive)
#  Default: 'info'
# c.ConfigurableHTTPProxy.log_level = 'info'

## File in which to write the PID of the proxy process.
#  Default: 'jupyterhub-proxy.pid'
# c.ConfigurableHTTPProxy.pid_file = 'jupyterhub-proxy.pid'

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.ConfigurableHTTPProxy.should_start = True

#------------------------------------------------------------------------------
# TraefikEtcdProxy(TKvProxy) configuration
#------------------------------------------------------------------------------
## JupyterHub Proxy implementation using traefik and etcd

## Timeout (in seconds) when waiting for traefik to register an updated route.
#  See also: TraefikProxy.check_route_timeout
# c.TraefikEtcdProxy.check_route_timeout = 30

## 
#  See also: TraefikProxy.concurrency
# c.TraefikEtcdProxy.concurrency = 10

## 
#  See also: TraefikProxy.enable_setup_dynamic_config
# c.TraefikEtcdProxy.enable_setup_dynamic_config = True

## Extra keyword arguments to pass to the etcd Python client constructor
#  Default: {}
# c.TraefikEtcdProxy.etcd_client_kwargs = {}

## Password for accessing etcd.
#  Default: ''
# c.TraefikEtcdProxy.etcd_password = ''

## URL for the etcd endpoint.
#  Default: 'http://127.0.0.1:2379'
# c.TraefikEtcdProxy.etcd_url = 'http://127.0.0.1:2379'

## Username for accessing etcd.
#  Default: ''
# c.TraefikEtcdProxy.etcd_username = ''

## Extra dynamic configuration for treafik.
#  See also: TraefikProxy.extra_dynamic_config
# c.TraefikEtcdProxy.extra_dynamic_config = {}

## 
#  See also: Proxy.extra_routes
# c.TraefikEtcdProxy.extra_routes = {}

## Extra static configuration for treafik.
#  See also: TraefikProxy.extra_static_config
# c.TraefikEtcdProxy.extra_static_config = {}

## The key value store key prefix for traefik dynamic configuration
#  See also: TKvProxy.kv_jupyterhub_prefix
# c.TraefikEtcdProxy.kv_jupyterhub_prefix = 'jupyterhub'

#  Default: 'DEPRECATED'
# c.TraefikEtcdProxy.kv_password = 'DEPRECATED'

## The separator used for the path in the KV store
#  See also: TKvProxy.kv_separator
# c.TraefikEtcdProxy.kv_separator = '/'

## The key value store key prefix for traefik static configuration
#  See also: TKvProxy.kv_traefik_prefix
# c.TraefikEtcdProxy.kv_traefik_prefix = 'traefik'

#  Default: 'DEPRECATED'
# c.TraefikEtcdProxy.kv_url = 'DEPRECATED'

#  Default: 'DEPRECATED'
# c.TraefikEtcdProxy.kv_username = 'DEPRECATED'

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.TraefikEtcdProxy.should_start = True

## traefik's static configuration file
#  See also: TraefikProxy.static_config_file
# c.TraefikEtcdProxy.static_config_file = 'traefik.toml'

## Deprecated. Use static_config_file
#  See also: TraefikProxy.toml_static_config_file
# c.TraefikEtcdProxy.toml_static_config_file = ''

## The traefik entrypoint name to use for API access.
#  See also: TraefikProxy.traefik_api_entrypoint
# c.TraefikEtcdProxy.traefik_api_entrypoint = 'auth_api'

## The password for traefik api login
#  See also: TraefikProxy.traefik_api_password
# c.TraefikEtcdProxy.traefik_api_password = ''

## traefik authenticated api endpoint url
#  See also: TraefikProxy.traefik_api_url
# c.TraefikEtcdProxy.traefik_api_url = 'http://localhost:8099'

## The username for traefik api login
#  See also: TraefikProxy.traefik_api_username
# c.TraefikEtcdProxy.traefik_api_username = ''

## validate SSL certificate of traefik api endpoint
#  See also: TraefikProxy.traefik_api_validate_cert
# c.TraefikEtcdProxy.traefik_api_validate_cert = True

## The traefik entrypoint name to use.
#  See also: TraefikProxy.traefik_entrypoint
# c.TraefikEtcdProxy.traefik_entrypoint = ''

## Environment variables to set for the traefik process.
#  See also: TraefikProxy.traefik_env
# c.TraefikEtcdProxy.traefik_env = {}

## traefik's log level
#  See also: TraefikProxy.traefik_log_level
# c.TraefikEtcdProxy.traefik_log_level = ''

## 
#  See also: TraefikProxy.traefik_providers_throttle_duration
# c.TraefikEtcdProxy.traefik_providers_throttle_duration = '0s'

#------------------------------------------------------------------------------
# TraefikConsulProxy(TKvProxy) configuration
#------------------------------------------------------------------------------
## JupyterHub Proxy implementation using traefik and Consul

## Timeout (in seconds) when waiting for traefik to register an updated route.
#  See also: TraefikProxy.check_route_timeout
# c.TraefikConsulProxy.check_route_timeout = 30

## 
#  See also: TraefikProxy.concurrency
# c.TraefikConsulProxy.concurrency = 10

## Extra consul client constructor arguments
#  Default: {}
# c.TraefikConsulProxy.consul_client_kwargs = {}

## Password or token for accessing consul.
#  Default: ''
# c.TraefikConsulProxy.consul_password = ''

## URL for the consul endpoint.
#  Default: 'http://127.0.0.1:8500'
# c.TraefikConsulProxy.consul_url = 'http://127.0.0.1:8500'

## Usrname for accessing consul.
#  Default: ''
# c.TraefikConsulProxy.consul_username = ''

## 
#  See also: TraefikProxy.enable_setup_dynamic_config
# c.TraefikConsulProxy.enable_setup_dynamic_config = True

## Extra dynamic configuration for treafik.
#  See also: TraefikProxy.extra_dynamic_config
# c.TraefikConsulProxy.extra_dynamic_config = {}

## 
#  See also: Proxy.extra_routes
# c.TraefikConsulProxy.extra_routes = {}

## Extra static configuration for treafik.
#  See also: TraefikProxy.extra_static_config
# c.TraefikConsulProxy.extra_static_config = {}

## The key value store key prefix for traefik dynamic configuration
#  See also: TKvProxy.kv_jupyterhub_prefix
# c.TraefikConsulProxy.kv_jupyterhub_prefix = 'jupyterhub'

#  Default: 'DEPRECATED'
# c.TraefikConsulProxy.kv_password = 'DEPRECATED'

## The separator used for the path in the KV store
#  See also: TKvProxy.kv_separator
# c.TraefikConsulProxy.kv_separator = '/'

## The key value store key prefix for traefik static configuration
#  See also: TKvProxy.kv_traefik_prefix
# c.TraefikConsulProxy.kv_traefik_prefix = 'traefik'

#  Default: 'DEPRECATED'
# c.TraefikConsulProxy.kv_url = 'DEPRECATED'

#  Default: 'DEPRECATED'
# c.TraefikConsulProxy.kv_username = 'DEPRECATED'

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.TraefikConsulProxy.should_start = True

## traefik's static configuration file
#  See also: TraefikProxy.static_config_file
# c.TraefikConsulProxy.static_config_file = 'traefik.toml'

## Deprecated. Use static_config_file
#  See also: TraefikProxy.toml_static_config_file
# c.TraefikConsulProxy.toml_static_config_file = ''

## The traefik entrypoint name to use for API access.
#  See also: TraefikProxy.traefik_api_entrypoint
# c.TraefikConsulProxy.traefik_api_entrypoint = 'auth_api'

## The password for traefik api login
#  See also: TraefikProxy.traefik_api_password
# c.TraefikConsulProxy.traefik_api_password = ''

## traefik authenticated api endpoint url
#  See also: TraefikProxy.traefik_api_url
# c.TraefikConsulProxy.traefik_api_url = 'http://localhost:8099'

## The username for traefik api login
#  See also: TraefikProxy.traefik_api_username
# c.TraefikConsulProxy.traefik_api_username = ''

## validate SSL certificate of traefik api endpoint
#  See also: TraefikProxy.traefik_api_validate_cert
# c.TraefikConsulProxy.traefik_api_validate_cert = True

## The traefik entrypoint name to use.
#  See also: TraefikProxy.traefik_entrypoint
# c.TraefikConsulProxy.traefik_entrypoint = ''

## Environment variables to set for the traefik process.
#  See also: TraefikProxy.traefik_env
# c.TraefikConsulProxy.traefik_env = {}

## traefik's log level
#  See also: TraefikProxy.traefik_log_level
# c.TraefikConsulProxy.traefik_log_level = ''

## 
#  See also: TraefikProxy.traefik_providers_throttle_duration
# c.TraefikConsulProxy.traefik_providers_throttle_duration = '0s'

#------------------------------------------------------------------------------
# Auth0OAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: OAuthenticator.admin_groups
# c.Auth0OAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.Auth0OAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.Auth0OAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.Auth0OAuthenticator.allow_existing_users = False

## 
#  See also: OAuthenticator.allowed_groups
# c.Auth0OAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.Auth0OAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.Auth0OAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.Auth0OAuthenticator.any_allow_config = False

## The domain for your Auth0 account.
#  
#  Used to determine the default values for `logout_redirect_url`,
#  `authorize_url`, `token_url`, and `userdata_url`.
#  Default: ''
# c.Auth0OAuthenticator.auth0_domain = ''

## A shorthand for configuring `auth0_domain`, if configured to "something", it
#  is the same as configuring `auth0_domain` to "something.auth0.com".
#  Default: ''
# c.Auth0OAuthenticator.auth0_subdomain = ''

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.Auth0OAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.Auth0OAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.Auth0OAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.Auth0OAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.Auth0OAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.Auth0OAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.Auth0OAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.Auth0OAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.Auth0OAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.Auth0OAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.Auth0OAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.Auth0OAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.Auth0OAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.Auth0OAuthenticator.extra_authorize_params = {}

## 
#  See also: OAuthenticator.http_request_kwargs
# c.Auth0OAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.Auth0OAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.Auth0OAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.Auth0OAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.Auth0OAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.Auth0OAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.Auth0OAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.Auth0OAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.Auth0OAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.Auth0OAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.Auth0OAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.Auth0OAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.Auth0OAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.Auth0OAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.Auth0OAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.Auth0OAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.Auth0OAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.Auth0OAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.Auth0OAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.Auth0OAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.Auth0OAuthenticator.username_claim = traitlets.Undefined

## .. deprecated:: 16.0
#  
#     Use :attr:`username_claim`.
#  Default: ''
# c.Auth0OAuthenticator.username_key = ''

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.Auth0OAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.Auth0OAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.Auth0OAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.Auth0OAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalAuth0OAuthenticator(LocalAuthenticator, Auth0OAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalAuth0OAuthenticator.add_user_cmd = []

## 
#  See also: OAuthenticator.admin_groups
# c.LocalAuth0OAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalAuth0OAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalAuth0OAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalAuth0OAuthenticator.allow_existing_users = False

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalAuth0OAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalAuth0OAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalAuth0OAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalAuth0OAuthenticator.any_allow_config = False

## 
#  See also: Auth0OAuthenticator.auth0_domain
# c.LocalAuth0OAuthenticator.auth0_domain = ''

## 
#  See also: Auth0OAuthenticator.auth0_subdomain
# c.LocalAuth0OAuthenticator.auth0_subdomain = ''

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalAuth0OAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalAuth0OAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalAuth0OAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalAuth0OAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalAuth0OAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalAuth0OAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalAuth0OAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.LocalAuth0OAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalAuth0OAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalAuth0OAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalAuth0OAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalAuth0OAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalAuth0OAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalAuth0OAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalAuth0OAuthenticator.extra_authorize_params = {}

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalAuth0OAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalAuth0OAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.LocalAuth0OAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalAuth0OAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalAuth0OAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalAuth0OAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalAuth0OAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalAuth0OAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalAuth0OAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalAuth0OAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalAuth0OAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalAuth0OAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalAuth0OAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalAuth0OAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.LocalAuth0OAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.LocalAuth0OAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalAuth0OAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalAuth0OAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalAuth0OAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalAuth0OAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalAuth0OAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalAuth0OAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalAuth0OAuthenticator.username_claim = traitlets.Undefined

## 
#  See also: Auth0OAuthenticator.username_key
# c.LocalAuth0OAuthenticator.username_key = ''

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalAuth0OAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalAuth0OAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalAuth0OAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalAuth0OAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# NativeAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: Authenticator.admin_users
# c.NativeAuthenticator.admin_users = set()

#  Default: False
# c.NativeAuthenticator.allow_2fa = False

## 
#  See also: Authenticator.allow_all
# c.NativeAuthenticator.allow_all = False

## 
#  See also: Authenticator.allow_existing_users
# c.NativeAuthenticator.allow_existing_users = False

## Use self-service authentication (rather than admin-based authentication) for
#  users whose email match this patter. Note that this forces ask_email_on_signup
#  to be True.
#  Default: ''
# c.NativeAuthenticator.allow_self_approval_for = ''

## Configures the number of failed attempts a user can have before being blocked.
#  Default: 0
# c.NativeAuthenticator.allowed_failed_logins = 0

## 
#  See also: Authenticator.allowed_users
# c.NativeAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.NativeAuthenticator.any_allow_config = False

## Asks for email on signup
#  Default: False
# c.NativeAuthenticator.ask_email_on_signup = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.NativeAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.NativeAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.NativeAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: Authenticator.blocked_users
# c.NativeAuthenticator.blocked_users = set()

## Creates a verification of password strength when a new user makes signup
#  Default: False
# c.NativeAuthenticator.check_common_password = False

## Deletes FirstUse Authenticator database after the import
#  Default: False
# c.NativeAuthenticator.delete_firstuse_db_after_import = False

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.NativeAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.NativeAuthenticator.enable_auth_state = False

## Allows every user to registry a new account
#  Default: True
# c.NativeAuthenticator.enable_signup = True

## Path to store the db file of FirstUse with username / pwd hash in
#  Default: 'passwords.dbm'
# c.NativeAuthenticator.firstuse_db_path = 'passwords.dbm'

## Import users from FirstUse Authenticator database
#  Default: False
# c.NativeAuthenticator.import_from_firstuse = False

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.NativeAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.NativeAuthenticator.manage_roles = False

## Check if the length of the password is at least this size on signup
#  Default: 0
# c.NativeAuthenticator.minimum_password_length = 0

## Allows every user that made sign up to automatically log in the system without
#  needing admin authorization
#  Default: False
# c.NativeAuthenticator.open_signup = False

## 
#  See also: Authenticator.otp_prompt
# c.NativeAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.NativeAuthenticator.post_auth_hook = None

## Your key to enable reCAPTCHA as described at
#  https://developers.google.com/recaptcha/intro
#  Default: ''
# c.NativeAuthenticator.recaptcha_key = ''

## Your secret to enable reCAPTCHA as described at
#  https://developers.google.com/recaptcha/intro
#  Default: ''
# c.NativeAuthenticator.recaptcha_secret = ''

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.NativeAuthenticator.refresh_pre_spawn = False

## 
#  See also: Authenticator.request_otp
# c.NativeAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.NativeAuthenticator.reset_managed_roles_on_startup = False

## Configures the number of seconds a user has to wait after being blocked.
#  Default is 600.
#  Default: 0
# c.NativeAuthenticator.seconds_before_next_try = 0

## Secret key to cryptographically sign the self-approved URL (if
#  allow_self_approval is utilized)
#  Default: ''
# c.NativeAuthenticator.secret_key = ''

#  Default: ('do-not-reply@my-domain.com', 'Welcome to JupyterHub on my-domain', "Your JupyterHub account on my-domain has been created, but it's inactive.\nIf you did not create the account yourself, IGNORE this message:\nsomebody is trying to use your email to get an unathorized account!\nIf you did create the account yourself, navigate to {approval_url} to activate it.\n")
# c.NativeAuthenticator.self_approval_email = ('do-not-reply@my-domain.com', 'Welcome to JupyterHub on my-domain', "Your JupyterHub account on my-domain has been created, but it's inactive.\nIf you did not create the account yourself, IGNORE this message:\nsomebody is trying to use your email to get an unathorized account!\nIf you did create the account yourself, navigate to {approval_url} to activate it.\n")

## SMTP server information as a dictionary of 'url', 'usr'and 'pwd' to use for
#  sending email, e.g.self_approval_server={'url': 'smtp.gmail.com', 'usr':
#  'myself''pwd': 'mypassword'}
#  Default: {}
# c.NativeAuthenticator.self_approval_server = {}

## The HTML to present next to the Term of Service checkbox
#  Default: ''
# c.NativeAuthenticator.tos = ''

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.NativeAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.NativeAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.NativeAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# GitLabOAuthenticator(OAuthenticator) configuration
#------------------------------------------------------------------------------
## 
#  See also: OAuthenticator.admin_groups
# c.GitLabOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.GitLabOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.GitLabOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.GitLabOAuthenticator.allow_existing_users = False

## Allow members of selected GitLab groups to sign in.
#  
#  Note that for each group allowed, an additional REST API call needs to be made
#  when a user is signing in. To reduce the risk of JupyterHub being rate
#  limited, don't specify too many.
#  Default: set()
# c.GitLabOAuthenticator.allowed_gitlab_groups = set()

## 
#  See also: OAuthenticator.allowed_groups
# c.GitLabOAuthenticator.allowed_groups = set()

## Allow members with Developer access or higher in selected project ids to sign
#  in.
#  
#  Note that for each project allowed, an additional REST API call needs to be
#  made when a user is signing in. To reduce the risk of JupyterHub being rate
#  limited, don't specify too many.
#  Default: set()
# c.GitLabOAuthenticator.allowed_project_ids = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.GitLabOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.GitLabOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.GitLabOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.GitLabOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.GitLabOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.GitLabOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.GitLabOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.GitLabOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.GitLabOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.GitLabOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.GitLabOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.GitLabOAuthenticator.client_secret = ''

## 
#  See also: OAuthenticator.custom_403_message
# c.GitLabOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.GitLabOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.GitLabOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.GitLabOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.GitLabOAuthenticator.extra_authorize_params = {}

## Used to determine the default value for `userdata_url`.
#  Default: ''
# c.GitLabOAuthenticator.gitlab_api = ''

## Used to determine the default values for `gitlab_api`.
#  
#  For details, see https://docs.gitlab.com/ee/api/rest/.
#  Default: ''
# c.GitLabOAuthenticator.gitlab_api_version = ''

## .. deprecated:: 0.12
#  
#     Use :attr:`allowed_gitlab_groups`.
#  Default: set()
# c.GitLabOAuthenticator.gitlab_group_whitelist = set()

## .. deprecated:: 0.12
#  
#     Use :attr:`allowed_project_ids`.
#  Default: set()
# c.GitLabOAuthenticator.gitlab_project_id_whitelist = set()

## Used to determine the default values for `gitlab_api`, `authorize_url`,
#  `token_url`.
#  Default: ''
# c.GitLabOAuthenticator.gitlab_url = ''

## 
#  See also: OAuthenticator.http_request_kwargs
# c.GitLabOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.GitLabOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.GitLabOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.GitLabOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.GitLabOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.GitLabOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.GitLabOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.GitLabOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.GitLabOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.GitLabOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.GitLabOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.GitLabOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.GitLabOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.GitLabOAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.GitLabOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.GitLabOAuthenticator.token_url = ''

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.GitLabOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.GitLabOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.GitLabOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.GitLabOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.GitLabOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.GitLabOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.GitLabOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.GitLabOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.GitLabOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalGitLabOAuthenticator.add_user_cmd = []

## 
#  See also: OAuthenticator.admin_groups
# c.LocalGitLabOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalGitLabOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalGitLabOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalGitLabOAuthenticator.allow_existing_users = False

## 
#  See also: GitLabOAuthenticator.allowed_gitlab_groups
# c.LocalGitLabOAuthenticator.allowed_gitlab_groups = set()

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalGitLabOAuthenticator.allowed_groups = set()

## 
#  See also: GitLabOAuthenticator.allowed_project_ids
# c.LocalGitLabOAuthenticator.allowed_project_ids = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalGitLabOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalGitLabOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalGitLabOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalGitLabOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalGitLabOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalGitLabOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalGitLabOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalGitLabOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalGitLabOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalGitLabOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.LocalGitLabOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalGitLabOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalGitLabOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalGitLabOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalGitLabOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalGitLabOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalGitLabOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalGitLabOAuthenticator.extra_authorize_params = {}

## 
#  See also: GitLabOAuthenticator.gitlab_api
# c.LocalGitLabOAuthenticator.gitlab_api = ''

## 
#  See also: GitLabOAuthenticator.gitlab_api_version
# c.LocalGitLabOAuthenticator.gitlab_api_version = ''

## 
#  See also: GitLabOAuthenticator.gitlab_group_whitelist
# c.LocalGitLabOAuthenticator.gitlab_group_whitelist = set()

## 
#  See also: GitLabOAuthenticator.gitlab_project_id_whitelist
# c.LocalGitLabOAuthenticator.gitlab_project_id_whitelist = set()

## 
#  See also: GitLabOAuthenticator.gitlab_url
# c.LocalGitLabOAuthenticator.gitlab_url = ''

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalGitLabOAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalGitLabOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.LocalGitLabOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalGitLabOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalGitLabOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalGitLabOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalGitLabOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalGitLabOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalGitLabOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalGitLabOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalGitLabOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalGitLabOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalGitLabOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalGitLabOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.LocalGitLabOAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.LocalGitLabOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalGitLabOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalGitLabOAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalGitLabOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalGitLabOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalGitLabOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalGitLabOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalGitLabOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalGitLabOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalGitLabOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalGitLabOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalGitLabOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# TmpAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## When JupyterHub is configured to use this authenticator, visiting the home
#  page immediately logs the user in with a randomly generated UUID if they are
#  already not logged in, and spawns a server for them.

## 
#  See also: Authenticator.admin_users
# c.TmpAuthenticator.admin_users = set()

## 
#  See also: Authenticator.allow_all
# c.TmpAuthenticator.allow_all = False

## 
#  See also: Authenticator.allow_existing_users
# c.TmpAuthenticator.allow_existing_users = False

## 
#  See also: Authenticator.allowed_users
# c.TmpAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.TmpAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.TmpAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.TmpAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.TmpAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: Authenticator.blocked_users
# c.TmpAuthenticator.blocked_users = set()

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.TmpAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.TmpAuthenticator.enable_auth_state = False

## Text to be shown with the 'Sign in with ...' button, when auto_login is False.
#  
#  The Authenticator base class' login_service isn't tagged as a configurable
#  traitlet, so we redefine it to allow it to be configurable like this:
#  
#      c.TmpAuthenticator.login_service = "your inherent worth as a human being"
#  Default: 'Automatic Temporary Credentials'
# c.TmpAuthenticator.login_service = 'Automatic Temporary Credentials'

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.TmpAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.TmpAuthenticator.manage_roles = False

## 
#  See also: Authenticator.otp_prompt
# c.TmpAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.TmpAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.TmpAuthenticator.refresh_pre_spawn = False

## 
#  See also: Authenticator.request_otp
# c.TmpAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.TmpAuthenticator.reset_managed_roles_on_startup = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.TmpAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.TmpAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.TmpAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# FirstUseAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## JupyterHub authenticator that lets users set password on first use.

## 
#  See also: Authenticator.admin_users
# c.FirstUseAuthenticator.admin_users = set()

## 
#  See also: Authenticator.allow_all
# c.FirstUseAuthenticator.allow_all = False

## 
#  See also: Authenticator.allow_existing_users
# c.FirstUseAuthenticator.allow_existing_users = False

## 
#  See also: Authenticator.allowed_users
# c.FirstUseAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.FirstUseAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.FirstUseAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.FirstUseAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.FirstUseAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: Authenticator.blocked_users
# c.FirstUseAuthenticator.blocked_users = set()

## Check for non-normalized-username passwords on startup.
#  
#  Prior to 1.0, multiple passwords could be set for the same username, without
#  normalization.
#  
#  When True, duplicate usernames will be detected and removed, and ensure all
#  usernames are normalized.
#  
#  If any duplicates are found, a backup of the original is created, which can be
#  inspected manually.
#  
#  Typically, this will only need to run once.
#  Default: True
# c.FirstUseAuthenticator.check_passwords_on_startup = True

## Create users if they do not exist already.
#  
#  When set to false, users would have to be explicitly created before they can
#  log in. Users can be created via the admin panel or by setting whitelist /
#  admin list.
#  Default: True
# c.FirstUseAuthenticator.create_users = True

## Path to store the db file with username / pwd hash in
#  Default: 'passwords.dbm'
# c.FirstUseAuthenticator.dbm_path = 'passwords.dbm'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.FirstUseAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.FirstUseAuthenticator.enable_auth_state = False

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.FirstUseAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.FirstUseAuthenticator.manage_roles = False

## The minimum length of the password when user is created. When set to 0, users
#  will be allowed to set 0 length passwords.
#  Default: 7
# c.FirstUseAuthenticator.min_password_length = 7

## 
#  See also: Authenticator.otp_prompt
# c.FirstUseAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.FirstUseAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.FirstUseAuthenticator.refresh_pre_spawn = False

## 
#  See also: Authenticator.request_otp
# c.FirstUseAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.FirstUseAuthenticator.reset_managed_roles_on_startup = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.FirstUseAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.FirstUseAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.FirstUseAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalBitbucketOAuthenticator(LocalAuthenticator, BitbucketOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalBitbucketOAuthenticator.add_user_cmd = []

## 
#  See also: OAuthenticator.admin_groups
# c.LocalBitbucketOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalBitbucketOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalBitbucketOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalBitbucketOAuthenticator.allow_existing_users = False

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalBitbucketOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalBitbucketOAuthenticator.allowed_scopes = []

## 
#  See also: BitbucketOAuthenticator.allowed_teams
# c.LocalBitbucketOAuthenticator.allowed_teams = set()

## 
#  See also: Authenticator.allowed_users
# c.LocalBitbucketOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalBitbucketOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalBitbucketOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalBitbucketOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalBitbucketOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalBitbucketOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalBitbucketOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalBitbucketOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalBitbucketOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.LocalBitbucketOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalBitbucketOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalBitbucketOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalBitbucketOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalBitbucketOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalBitbucketOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalBitbucketOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalBitbucketOAuthenticator.extra_authorize_params = {}

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalBitbucketOAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalBitbucketOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.LocalBitbucketOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalBitbucketOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalBitbucketOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalBitbucketOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalBitbucketOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalBitbucketOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalBitbucketOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalBitbucketOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalBitbucketOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalBitbucketOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalBitbucketOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalBitbucketOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.LocalBitbucketOAuthenticator.scope = []

## 
#  See also: BitbucketOAuthenticator.team_whitelist
# c.LocalBitbucketOAuthenticator.team_whitelist = set()

## 
#  See also: OAuthenticator.token_params
# c.LocalBitbucketOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalBitbucketOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalBitbucketOAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalBitbucketOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalBitbucketOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalBitbucketOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalBitbucketOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalBitbucketOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalBitbucketOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalBitbucketOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalBitbucketOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalBitbucketOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# SystemdSpawner(Spawner) configuration
#------------------------------------------------------------------------------
## 
#  See also: Spawner.args
# c.SystemdSpawner.args = []

## 
#  See also: Spawner.auth_state_hook
# c.SystemdSpawner.auth_state_hook = None

## 
#  See also: Spawner.cmd
# c.SystemdSpawner.cmd = ['jupyterhub-singleuser']

## 
#  See also: Spawner.consecutive_failure_limit
# c.SystemdSpawner.consecutive_failure_limit = 0

## 
#  See also: Spawner.cpu_guarantee
# c.SystemdSpawner.cpu_guarantee = None

## 
#  See also: Spawner.cpu_limit
# c.SystemdSpawner.cpu_limit = None

## Enable debug-logging of the single-user server
#  See also: Spawner.debug
# c.SystemdSpawner.debug = False

## Default shell for users on the notebook terminal
#  Default: '/bin/bash'
# c.SystemdSpawner.default_shell = '/bin/bash'

## 
#  See also: Spawner.default_url
# c.SystemdSpawner.default_url = ''

## 
#  See also: Spawner.disable_user_config
# c.SystemdSpawner.disable_user_config = False

## Set to true to disallow becoming root (or any other user) via sudo or other
#  means from inside the notebook
#  Default: True
# c.SystemdSpawner.disable_user_sudo = True

## Allocate system users dynamically for each user.
#  
#  Uses the DynamicUser= feature of Systemd to make a new system user for each
#  hub user dynamically. Their home directories are set up under
#  /var/lib/{USERNAME}, and persist over time. The system user is deallocated
#  whenever the user's server is not running.
#  
#  See http://0pointer.net/blog/dynamic-users-with-systemd.html for more
#  information.
#  Default: False
# c.SystemdSpawner.dynamic_users = False

## 
#  See also: Spawner.env_keep
# c.SystemdSpawner.env_keep = ['JUPYTERHUB_SINGLEUSER_APP']

## 
#  See also: Spawner.environment
# c.SystemdSpawner.environment = {}

## Extra paths to prepend to the $PATH environment variable.
#  
#  {USERNAME} and {USERID} are expanded
#  Default: []
# c.SystemdSpawner.extra_paths = []

## 
#  See also: Spawner.group_overrides
# c.SystemdSpawner.group_overrides = traitlets.Undefined

## 
#  See also: Spawner.http_timeout
# c.SystemdSpawner.http_timeout = 30

## 
#  See also: Spawner.hub_connect_url
# c.SystemdSpawner.hub_connect_url = None

## 
#  See also: Spawner.ip
# c.SystemdSpawner.ip = '127.0.0.1'

## Give each notebook user their own /dev, with a very limited set of devices
#  mounted
#  Default: False
# c.SystemdSpawner.isolate_devices = False

## Give each notebook user their own /tmp, isolated from the system & each other
#  Default: False
# c.SystemdSpawner.isolate_tmp = False

## 
#  See also: Spawner.mem_guarantee
# c.SystemdSpawner.mem_guarantee = None

## 
#  See also: Spawner.mem_limit
# c.SystemdSpawner.mem_limit = None

## 
#  See also: Spawner.notebook_dir
# c.SystemdSpawner.notebook_dir = ''

## Allowed scopes for oauth tokens issued by this server's oauth client.
#  See also: Spawner.oauth_client_allowed_scopes
# c.SystemdSpawner.oauth_client_allowed_scopes = traitlets.Undefined

## Allowed roles for oauth tokens.
#  See also: Spawner.oauth_roles
# c.SystemdSpawner.oauth_roles = traitlets.Undefined

## 
#  See also: Spawner.options_form
# c.SystemdSpawner.options_form = traitlets.Undefined

## 
#  See also: Spawner.options_from_form
# c.SystemdSpawner.options_from_form = traitlets.Undefined

## 
#  See also: Spawner.poll_interval
# c.SystemdSpawner.poll_interval = 30

## 
#  See also: Spawner.poll_jitter
# c.SystemdSpawner.poll_jitter = 0.1

## 
#  See also: Spawner.port
# c.SystemdSpawner.port = 0

## 
#  See also: Spawner.post_stop_hook
# c.SystemdSpawner.post_stop_hook = None

## 
#  See also: Spawner.pre_spawn_hook
# c.SystemdSpawner.pre_spawn_hook = None

## 
#  See also: Spawner.progress_ready_hook
# c.SystemdSpawner.progress_ready_hook = None

## List of paths that should be marked readonly from the user notebook.
#  
#  Subpaths maybe be made writeable by setting readwrite_paths
#  Default: []
# c.SystemdSpawner.readonly_paths = []

## List of paths that should be marked read-write from the user notebook.
#  
#  Used to make a subpath of a readonly path writeable
#  Default: []
# c.SystemdSpawner.readwrite_paths = []

## The list of scopes to request for $JUPYTERHUB_API_TOKEN
#  See also: Spawner.server_token_scopes
# c.SystemdSpawner.server_token_scopes = traitlets.Undefined

## Ensure that all users that are created are run within a given slice. This
#  allow global configuration of the maximum resources that all users
#  collectively can use by creating a a slice beforehand.
#  Default: None
# c.SystemdSpawner.slice = None

## List of SSL alt names
#  See also: Spawner.ssl_alt_names
# c.SystemdSpawner.ssl_alt_names = []

## Whether to include `DNS:localhost`, `IP:127.0.0.1` in alt names
#  See also: Spawner.ssl_alt_names_include_local
# c.SystemdSpawner.ssl_alt_names_include_local = True

## 
#  See also: Spawner.start_timeout
# c.SystemdSpawner.start_timeout = 60

## Dict of extra properties for systemd-run --property=[...].
#  
#  Keys are property names, and values are either strings or list of strings (for
#  multiple entries). When values are lists, ordering is guaranteed. Ordering
#  across keys of the dictionary are *not* guaranteed.
#  
#  Used to add arbitrary properties for spawned Jupyter units. Read `man systemd-
#  run` for details on per-unit properties available in transient units.
#  Default: {}
# c.SystemdSpawner.unit_extra_properties = {}

## Template to use to make the systemd service names.
#  
#  {USERNAME} and {USERID} are expanded}
#  Default: 'jupyter-{USERNAME}-singleuser'
# c.SystemdSpawner.unit_name_template = 'jupyter-{USERNAME}-singleuser'

## Path to start each notebook user on.
#  
#  {USERNAME} and {USERID} are expanded.
#  
#  Defaults to the home directory of the user.
#  
#  Not respected if dynamic_users is set to True.
#  Default: None
# c.SystemdSpawner.user_workingdir = None

## Template for unix username each user should be spawned as.
#  
#  {USERNAME} and {USERID} are expanded.
#  
#  This user should already exist in the system.
#  
#  Not respected if dynamic_users is set to True
#  Default: '{USERNAME}'
# c.SystemdSpawner.username_template = '{USERNAME}'

#------------------------------------------------------------------------------
# LocalGitHubOAuthenticator(LocalAuthenticator, GitHubOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalGitHubOAuthenticator.add_user_cmd = []

## 
#  See also: OAuthenticator.admin_groups
# c.LocalGitHubOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalGitHubOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalGitHubOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalGitHubOAuthenticator.allow_existing_users = False

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalGitHubOAuthenticator.allowed_groups = set()

## 
#  See also: GitHubOAuthenticator.allowed_organizations
# c.LocalGitHubOAuthenticator.allowed_organizations = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalGitHubOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalGitHubOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalGitHubOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalGitHubOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalGitHubOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalGitHubOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalGitHubOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalGitHubOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalGitHubOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalGitHubOAuthenticator.blocked_users = set()

## 
#  See also: OAuthenticator.client_id
# c.LocalGitHubOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalGitHubOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalGitHubOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalGitHubOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalGitHubOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalGitHubOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalGitHubOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalGitHubOAuthenticator.extra_authorize_params = {}

## 
#  See also: GitHubOAuthenticator.github_api
# c.LocalGitHubOAuthenticator.github_api = ''

## 
#  See also: GitHubOAuthenticator.github_client_id
# c.LocalGitHubOAuthenticator.github_client_id = ''

## 
#  See also: GitHubOAuthenticator.github_client_secret
# c.LocalGitHubOAuthenticator.github_client_secret = ''

## 
#  See also: GitHubOAuthenticator.github_organization_whitelist
# c.LocalGitHubOAuthenticator.github_organization_whitelist = set()

## 
#  See also: GitHubOAuthenticator.github_url
# c.LocalGitHubOAuthenticator.github_url = ''

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalGitHubOAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalGitHubOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.LocalGitHubOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalGitHubOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalGitHubOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalGitHubOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalGitHubOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalGitHubOAuthenticator.oauth_callback_url = ''

## 
#  See also: Authenticator.otp_prompt
# c.LocalGitHubOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: GitHubOAuthenticator.populate_teams_in_auth_state
# c.LocalGitHubOAuthenticator.populate_teams_in_auth_state = False

## 
#  See also: Authenticator.post_auth_hook
# c.LocalGitHubOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalGitHubOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalGitHubOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalGitHubOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalGitHubOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.LocalGitHubOAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.LocalGitHubOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalGitHubOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalGitHubOAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalGitHubOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalGitHubOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalGitHubOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalGitHubOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalGitHubOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalGitHubOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalGitHubOAuthenticator.username_pattern = ''

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalGitHubOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalGitHubOAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalOpenShiftOAuthenticator(LocalAuthenticator, OpenShiftOAuthenticator) configuration
#------------------------------------------------------------------------------
## A version that mixes in local system user creation

## 
#  See also: LocalAuthenticator.add_user_cmd
# c.LocalOpenShiftOAuthenticator.add_user_cmd = []

## 
#  See also: OAuthenticator.admin_groups
# c.LocalOpenShiftOAuthenticator.admin_groups = set()

## 
#  See also: Authenticator.admin_users
# c.LocalOpenShiftOAuthenticator.admin_users = set()

## 
#  See also: OAuthenticator.allow_all
# c.LocalOpenShiftOAuthenticator.allow_all = False

## 
#  See also: OAuthenticator.allow_existing_users
# c.LocalOpenShiftOAuthenticator.allow_existing_users = False

## 
#  See also: LocalAuthenticator.allowed_groups
# c.LocalOpenShiftOAuthenticator.allowed_groups = set()

## 
#  See also: OAuthenticator.allowed_scopes
# c.LocalOpenShiftOAuthenticator.allowed_scopes = []

## 
#  See also: Authenticator.allowed_users
# c.LocalOpenShiftOAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalOpenShiftOAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalOpenShiftOAuthenticator.auth_refresh_age = 300

## 
#  See also: OAuthenticator.auth_state_groups_key
# c.LocalOpenShiftOAuthenticator.auth_state_groups_key = traitlets.Undefined

## 
#  See also: OAuthenticator.authorize_url
# c.LocalOpenShiftOAuthenticator.authorize_url = ''

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalOpenShiftOAuthenticator.auto_login = False

## 
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalOpenShiftOAuthenticator.auto_login_oauth2_authorize = False

## 
#  See also: OAuthenticator.basic_auth
# c.LocalOpenShiftOAuthenticator.basic_auth = False

## 
#  See also: Authenticator.blocked_users
# c.LocalOpenShiftOAuthenticator.blocked_users = set()

## 
#  See also: OpenShiftOAuthenticator.ca_certs
# c.LocalOpenShiftOAuthenticator.ca_certs = ''

## 
#  See also: OAuthenticator.client_id
# c.LocalOpenShiftOAuthenticator.client_id = ''

## 
#  See also: OAuthenticator.client_secret
# c.LocalOpenShiftOAuthenticator.client_secret = ''

## 
#  See also: LocalAuthenticator.create_system_users
# c.LocalOpenShiftOAuthenticator.create_system_users = False

## 
#  See also: OAuthenticator.custom_403_message
# c.LocalOpenShiftOAuthenticator.custom_403_message = 'Sorry, you are not currently authorized to use this hub. Please contact the hub administrator.'

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalOpenShiftOAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalOpenShiftOAuthenticator.enable_auth_state = False

## 
#  See also: OAuthenticator.enable_pkce
# c.LocalOpenShiftOAuthenticator.enable_pkce = True

## 
#  See also: OAuthenticator.extra_authorize_params
# c.LocalOpenShiftOAuthenticator.extra_authorize_params = {}

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.LocalOpenShiftOAuthenticator.group_whitelist = set()

## 
#  See also: OAuthenticator.http_request_kwargs
# c.LocalOpenShiftOAuthenticator.http_request_kwargs = {}

## 
#  See also: OAuthenticator.login_service
# c.LocalOpenShiftOAuthenticator.login_service = 'OAuth 2.0'

## 
#  See also: OAuthenticator.logout_redirect_url
# c.LocalOpenShiftOAuthenticator.logout_redirect_url = ''

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalOpenShiftOAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalOpenShiftOAuthenticator.manage_roles = False

## 
#  See also: OAuthenticator.modify_auth_state_hook
# c.LocalOpenShiftOAuthenticator.modify_auth_state_hook = None

## 
#  See also: OAuthenticator.oauth_callback_url
# c.LocalOpenShiftOAuthenticator.oauth_callback_url = ''

## 
#  See also: OpenShiftOAuthenticator.openshift_auth_api_url
# c.LocalOpenShiftOAuthenticator.openshift_auth_api_url = ''

## 
#  See also: OpenShiftOAuthenticator.openshift_rest_api_url
# c.LocalOpenShiftOAuthenticator.openshift_rest_api_url = ''

## 
#  See also: OpenShiftOAuthenticator.openshift_url
# c.LocalOpenShiftOAuthenticator.openshift_url = 'https://openshift.default.svc.cluster.local'

## 
#  See also: Authenticator.otp_prompt
# c.LocalOpenShiftOAuthenticator.otp_prompt = 'OTP:'

## 
#  See also: Authenticator.post_auth_hook
# c.LocalOpenShiftOAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalOpenShiftOAuthenticator.refresh_pre_spawn = False

## 
#  See also: OAuthenticator.refresh_user_hook
# c.LocalOpenShiftOAuthenticator.refresh_user_hook = None

## 
#  See also: Authenticator.request_otp
# c.LocalOpenShiftOAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalOpenShiftOAuthenticator.reset_managed_roles_on_startup = False

## 
#  See also: OAuthenticator.scope
# c.LocalOpenShiftOAuthenticator.scope = []

## 
#  See also: OAuthenticator.token_params
# c.LocalOpenShiftOAuthenticator.token_params = {}

## 
#  See also: OAuthenticator.token_url
# c.LocalOpenShiftOAuthenticator.token_url = ''

## 
#  See also: LocalAuthenticator.uids
# c.LocalOpenShiftOAuthenticator.uids = {}

## 
#  See also: OAuthenticator.userdata_from_id_token
# c.LocalOpenShiftOAuthenticator.userdata_from_id_token = False

## 
#  See also: OAuthenticator.userdata_params
# c.LocalOpenShiftOAuthenticator.userdata_params = {}

## 
#  See also: OAuthenticator.userdata_token_method
# c.LocalOpenShiftOAuthenticator.userdata_token_method = 'header'

## 
#  See also: OAuthenticator.userdata_url
# c.LocalOpenShiftOAuthenticator.userdata_url = ''

## 
#  See also: OAuthenticator.username_claim
# c.LocalOpenShiftOAuthenticator.username_claim = traitlets.Undefined

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalOpenShiftOAuthenticator.username_map = {}

## 
#  See also: Authenticator.username_pattern
# c.LocalOpenShiftOAuthenticator.username_pattern = ''

## 
#  See also: OpenShiftOAuthenticator.validate_cert
# c.LocalOpenShiftOAuthenticator.validate_cert = False

## 
#  See also: OAuthenticator.validate_server_cert
# c.LocalOpenShiftOAuthenticator.validate_server_cert = False

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalOpenShiftOAuthenticator.whitelist = set()
